---
title: "MSSM-Penn-Pitt - ACC and DLPFC - FEATURECOUNTS - GRCh38 - CQN - Sparse Model"
author: "Adapted from Kelsey Montgomery"
date: "11/8/2019"
output: html_document
---

```{r libs, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE}
## Load required libraries
library(CovariateAnalysis) # get the package from devtools::install_github('th1vairam/CovariateAnalysis@dev')
library(data.table)
library(tidyr)
library(plyr)
library(edgeR)
library(dplyr)
library(stringr)
library(R.utils)
library(ggplot2)
library(limma)
library(psych)
library(edgeR)
library(cqn)
library(lme4)
library(biomaRt)
library(knitr)
library(githubr) # get the package from devtools::install_github('brian-bot/githubr')
library(doParallel)
library(foreach)
cl = makeCluster(detectCores()-2)
registerDoParallel(cl)
options(xtable.type="html")
knitr::opts_chunk$set(
  echo=FALSE,
  warning=FALSE,
  message=FALSE,
  error = FALSE,
  tidy = FALSE,
  cache = TRUE,
  results='hide')
library(reticulate)
```

### Data download
#### Obtain count matrix and metadata from synapse.
```{r download.data, cache=TRUE}
downloadFile <- function(id){
  fread(syn_temp$get(id)$path, data.table = F)
}
downloadFile_version <- function(id , version){
  fread(syn_temp$get(id, version = version)$path, data.table = F)
}

# Download reprocessed counts
counts = 'syn21071622'
ALL_USED_IDs = counts
counts = downloadFile(counts) %>% data.frame()
counts$Chr <- NULL
counts$Start <- NULL
counts$End <- NULL
counts$Strand <- NULL
# Parse gene lengths
gene_lengths = counts[,c("Geneid", "Length")]
counts$Length <- NULL
gene_lengths <- rename(gene_lengths, gene_id = Geneid)
# Get ancestry vector calculated using gemtools
ANCESTRY_ID = 'syn2511399'
ALL_USED_IDs[length(ALL_USED_IDs)+1] = ANCESTRY_ID
ANCESTRY = downloadFile(ANCESTRY_ID) %>% 
  plyr::rename(c('DNA_report..Genotyping.Sample_ID' = 'SNP_report:Genotyping_Sample_ID'))
# Get genotype ids from synapse
GENOTYPE_ID = 'syn16816490'
ALL_USED_IDs = c(ALL_USED_IDs, GENOTYPE_ID)
GENOTYPE = downloadFile(GENOTYPE_ID) %>% 
  dplyr::select(Individual_ID, `SNP_report:Genotyping_Sample_ID`) %>%
  dplyr::inner_join(ANCESTRY)
#Get Metadata
metadata = 'syn16816488' 
ALL_USED_IDs[length(ALL_USED_IDs)+1] = metadata
metadata = downloadFile_version(metadata, version = 13)  %>% 
  dplyr::select(Individual_ID, Institution, Reported_Gender, Sex, Ethnicity, Age_of_Death, `PMI_(in_hours)`, Dx,
                Sample_RNA_ID, one_of('rnaSeq_isolation:RIN',
                                      'rnaSeq_report:Ribozero_Batch', 'rnaSeq_report:Library_Batch', 
                                      'rnaSeq_report:Flowcell_Batch','rnaSeq_dissection:Brain_Region',
                                      'rnaSeq_report:Exclude?',
                                      'rnaSeq_report:Mapped_Reads',
                                      'rnaSeq_report:Intragenic_Rate','rnaSeq_report:Intronic_Rate',
                                      'rnaSeq_report:Intergenic_Rate','rnaSeq_report:Genes_Detected',
                                      'rnaSeq_report:Expression_Profiling_Efficiency',
                                      'rnaSeq_report:rRNA_Rate',
                                      'rnaSeq_report:Total_Reads', 'rnaSeq_report:Percent_Aligned'))
METADATA = metadata %>%
  dplyr::left_join(GENOTYPE) %>%
  dplyr::rename(PMI = `PMI_(in_hours)`,
                ReportExclude = `rnaSeq_report:Exclude?`,
                SampleID = Sample_RNA_ID,
                LibraryBatch = `rnaSeq_report:Library_Batch`,
                FlowcellBatch = `rnaSeq_report:Flowcell_Batch`,
                RibozeroBatch = `rnaSeq_report:Ribozero_Batch`,
                Tissue = `rnaSeq_dissection:Brain_Region`,
                MappedReads = `rnaSeq_report:Mapped_Reads`,
                IntragenicRate = `rnaSeq_report:Intragenic_Rate`, 
                IntronicRate = `rnaSeq_report:Intronic_Rate`, 
                IntergenicRate = `rnaSeq_report:Intergenic_Rate`, 
                GenesDetected = `rnaSeq_report:Genes_Detected`,
                ExpProfEfficiency = `rnaSeq_report:Expression_Profiling_Efficiency`, 
                rRNARate = `rnaSeq_report:rRNA_Rate`,
                TotalReads = `rnaSeq_report:Total_Reads`, 
                AlignmentRate = `rnaSeq_report:Percent_Aligned`,
                RIN = `rnaSeq_isolation:RIN`) %>%
  dplyr::select(SampleID, Individual_ID, Institution, Reported_Gender,Sex, Ethnicity, Age_of_Death, PMI, Dx, 
                RIN, ReportExclude, EV.1, EV.2, EV.3, EV.4, EV.5,
                LibraryBatch, FlowcellBatch, RibozeroBatch, Tissue, MappedReads, TotalReads, GenesDetected, AlignmentRate,
                IntragenicRate, IntergenicRate, IntronicRate, ExpProfEfficiency, rRNARate) %>% 
  dplyr::filter(Institution %in% c("MSSM", "Penn", "Pitt")) %>% 
  dplyr::filter(SampleID %in% colnames(counts), !is.na(SampleID)) %>%
  dplyr::mutate(Dx = forcats::fct_recode(Dx,  Other = "AFF", Other = "BP", Control = "Control", SCZ = "SCZ"))
```

### Data preprocessing
```{r preprocess.data}
ind = METADATA$SampleID[which(METADATA$ReportExclude == 1)]
writeLines(paste('Following',length(ind),'samples are marked exclude'))
writeLines(paste(ind, collapse = ', '))
METADATA <- METADATA  %>% dplyr::filter(!(SampleID %in% ind)) 
ind = METADATA$SampleID [is.na(METADATA$Ethnicity) | is.na(METADATA$Institution) | is.na(METADATA$Dx)]
writeLines(paste('Following', length(ind), 'counts are missing clinical metadata'))
writeLines(paste(ind, collapse = ', '))
METADATA <- METADATA  %>% dplyr::filter(!(SampleID %in% ind)) 
ind = METADATA$SampleID [is.na(METADATA$PMI)]
writeLines(paste('Following', length(ind), 'counts are missing PMI'))
writeLines(paste(ind, collapse = ', '))
METADATA <- METADATA  %>% dplyr::filter(!(SampleID %in% ind)) 
ind = METADATA$SampleID [is.na(METADATA$Reported_Gender)]
writeLines(paste('Following', length(ind), 'counts are missing gender'))
writeLines(paste(ind, collapse = ', '))
METADATA <- METADATA  %>% dplyr::filter(!(SampleID %in% ind)) 
ind = METADATA$SampleID [is.na(METADATA$Age_of_Death)]
writeLines(paste('Following', length(ind), 'counts are missing age of death'))
writeLines(paste(ind, collapse = ', '))
METADATA <- METADATA  %>% dplyr::filter(!(SampleID %in% ind))
ind = METADATA$SampleID [is.na(METADATA$EV.1)]
writeLines(paste('Following', length(ind), 'counts are missing ancestry information'))
writeLines(paste(ind, collapse = ', '))
METADATA <- METADATA  %>% dplyr::filter(!(SampleID %in% ind))
```

```{r preprocess.data1, results='asis'}
# Match covariates to expression data
indToRetain = intersect(METADATA$SampleID, colnames(counts))
rownames(counts) <- counts$Geneid
counts = counts[,indToRetain]
rownames(METADATA) = METADATA$SampleID
METADATA = METADATA[indToRetain,]
METADATA %>% 
  group_by(Dx, Tissue) %>% 
  summarise(count = n()) %>% 
  spread(Tissue, count) %>%
  kable()
METADATA = METADATA %>%
  dplyr::mutate(Dx.Tissue = paste(Dx, Tissue, sep = '.'))
```
Following sample are removed `r paste(removedIDs, collapse = ',')`

```{r gene.param}
## Get GC content from biomart
backgroundGenes = data.frame(gene_id = rownames(counts)) %>%
  dplyr::mutate(id = gene_id) %>%
  tidyr::separate(id, c('ensembl_gene_id','position'), sep = '\\.')
# Define biomart object
mart <- useMart(biomart = "ENSEMBL_MART_ENSEMBL", host = "jul2019.archive.ensembl.org", dataset = "hsapiens_gene_ensembl")
# Query biomart
Ensemble2HGNC <- getBM(attributes = c("ensembl_gene_id", "hgnc_symbol", "percentage_gene_gc_content", "gene_biotype", "chromosome_name"),
                       filters = "ensembl_gene_id", values = backgroundGenes$ensembl_gene_id,
                       mart = mart)
GENE.GC.CONT = Ensemble2HGNC %>%
  dplyr::left_join(backgroundGenes) %>% 
  dplyr::select(gene_id, percentage_gene_gc_content, chromosome_name) %>%
  unique
rownames(GENE.GC.CONT) = GENE.GC.CONT$gene_id
```

### Sex Check
```{r Reported_Gender_plots}
counts$gene_id = rownames(counts) 
REPORTED.GENDER.COUNTS = GENE.GC.CONT %>% 
  left_join(counts) %>%
  dplyr::select(-one_of("percentage_gene_gc_content")) %>%
  filter(chromosome_name == "X" |chromosome_name == "Y") %>% 
  tidyr::gather(key = item, value = value, -c(gene_id, chromosome_name)) %>%
  mutate(value = log(value)) %>%
  rename(`counts(log)`= value) %>% 
  rename(SampleID = item) %>%
  left_join(METADATA[,c("SampleID", "Reported_Gender")]) %>% 
  rename(`Reported Gender` = Reported_Gender) 
##XIST and UTY expression 
#ENSG00000229807.10 (sep), .11(jul) and ENSG00000183878.15 

FILT <- REPORTED.GENDER.COUNTS %>% 
  filter(gene_id == "ENSG00000229807.11" | gene_id == "ENSG00000183878.15") %>% 
  dplyr::select(-one_of("chromosome_name")) %>% 
  tidyr::spread(key = gene_id, value = `counts(log)`) %>% 
  mutate(XIST = as.numeric(`ENSG00000229807.11`)) %>% 
  mutate(UTY = as.numeric(`ENSG00000183878.15`))
p = ggplot(FILT, aes (x= XIST, y = UTY)) 
p = p + geom_point(aes(color=`Reported Gender`)) 
p
```
### Covariates clustering
Determine relationship between covariates. 
```{r covariates.clustering}
####_# Add diagnosis in here: (Dx)
FactorCovariates <- c('Individual_ID', "Institution", "Reported_Gender", "LibraryBatch", "Dx.Tissue", "RibozeroBatch", 'Dx', "FlowcellBatch")
ContCovariates <- c("Age_of_Death", "PMI", "RIN", "MappedReads", "IntragenicRate", "IntronicRate", "IntergenicRate",
                    "GenesDetected", "ExpProfEfficiency", "rRNARate", "TotalReads","AlignmentRate", 
                     "EV.1", "EV.2", "EV.3", "EV.4", "EV.5")
# Find inter relation between factor covariates
COVARIATES = METADATA[,c(FactorCovariates,ContCovariates),drop=F]
COVARIATES[,FactorCovariates] <- data.frame(lapply(COVARIATES[,FactorCovariates],function(x){
  x <- sapply(x,function(y){str_replace_all(as.character(y),'[^[:alnum:]]','_')})}))
rownames(COVARIATES) <- METADATA$SampleID
# Convert factor covariates to factors
COVARIATES[,FactorCovariates] = lapply(COVARIATES[,FactorCovariates], factor)
COVARIATES[,ContCovariates] = lapply(COVARIATES[,ContCovariates], function(x){
  x = as.numeric(as.character(gsub('[\\,\\%]','',x)))
})
# Add in RIN^2 values
COVARIATES$RIN2 = COVARIATES$RIN^2
ContCovariates = c(ContCovariates, 'RIN2')
```
Correlation/association between covariates at an FDR <= 0.1
```{r covariates.correlation, fig.width=10, fig.height=8}
COVARIATES.CORRELATION = getAssociationStatistics(COVARIATES, PVAL = 0.05)
tmp = COVARIATES.CORRELATION$ESTIMATE
tmp[COVARIATES.CORRELATION$PVAL > 0.05] = 0
h = Heatmap(tmp, col = colorRamp2(c(-1,0,1), c('blue','white','red')), name = 'AssocEstimate')
draw(h, heatmap_legend_side = 'left')
```

## Explore metatdata
```{r data.explore, fig.width = 12, fig.height = 12}
my.theme <- theme_bw() %+replace% theme(legend.position = 'top', axis.text.x = element_text(angle = 90, hjust = 1), plot.title=element_text(hjust=0.5))
# RIN
p = list()
p[[1]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = RIN)) + geom_boxplot()
p[[1]] = p[[1]] + ggtitle('RIN') + my.theme
# Age of Death
p[[2]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = Age_of_Death)) + geom_boxplot()
p[[2]] = p[[2]] + ggtitle('AgeOfDeath') + my.theme
# PMI
p[[3]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = PMI)) + geom_boxplot()
p[[3]] = p[[3]] + ggtitle('PMI (in hours)') + my.theme
# Intronic Rate
p[[4]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = IntronicRate)) + geom_boxplot()
p[[4]] = p[[4]] + ggtitle('Intronic Rate') + my.theme
# IntergenicRate
p[[5]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = IntergenicRate)) + geom_boxplot()
p[[5]] = p[[5]] + ggtitle('Intergenic Rate') + my.theme
# Transcripts Detected
p[[6]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = IntragenicRate)) + geom_boxplot()
p[[6]] = p[[6]] + ggtitle('Intragenic Rate') + my.theme
# Mapped Reads
p[[7]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = MappedReads)) + geom_boxplot()
p[[7]] = p[[7]] + ggtitle('Mapped Reads') + my.theme
# PercentAligned
p[[8]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = TotalReads)) + geom_boxplot()
p[[8]] = p[[8]] + ggtitle('Total Reads') + my.theme
# rRNARate
p[[9]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = rRNARate)) + geom_boxplot()
p[[9]] = p[[9]] + ggtitle('rRNARate') + my.theme
multiplot(plotlist = p, cols = 3)
# Institution
# vcd::mosaic(~ Institution + Dx.Tissue, data = COVARIATES)
# Gender
# vcd::mosaic(~ Gender + Dx.Tissue, data = COVARIATES)
```
### Filter genes
Remove genes that have less than 1 cpm counts in at least 50% of samples per Dx.Tissue. Also remove genes with missing gene length and percentage GC content
```{r cpmnormalisation}
counts$gene_id = NULL
genesToAnalyze = dlply(METADATA, .(Dx.Tissue, Reported_Gender), .fun = function(mtd, count){
  processed.counts = getGeneFilteredGeneExprMatrix(count[,mtd$SampleID],
                                                   MIN_GENE_CPM=1, 
                                                   MIN_SAMPLE_PERCENT_WITH_MIN_GENE_CPM=0.5)
  processed.counts$filteredExprMatrix$genes
}, counts)
genesToAnalyze = unlist(genesToAnalyze) %>% 
  unique() %>%
  intersect(GENE.GC.CONT$gene_id[!is.na(GENE.GC.CONT$percentage_gene_gc_content)]) %>%
  intersect(gene_lengths$gene_id[!is.na(gene_lengths$Length)])
#Subset union of all genes and convert subset to logcpm values 
PROCESSED_COUNTS = getGeneFilteredGeneExprMatrix(counts[genesToAnalyze, ], MIN_GENE_CPM=0, MIN_SAMPLE_PERCENT_WITH_MIN_GENE_CPM=0)
pct.pc = PROCESSED_COUNTS$filteredExprMatrix$genes %>%
  dplyr::rename(gene_id = genes) %>%
  left_join(backgroundGenes) %>%
  left_join(Ensemble2HGNC) %>%
  group_by(gene_biotype) %>%
  summarise(fraction  = n()) %>%
  filter(fraction > 100) %>%
  dplyr::mutate(fraction = fraction/length(PROCESSED_COUNTS$filteredExprMatrix$genes[,1]))
```
`r dim(PROCESSED_COUNTS$filteredExprMatrix$genes)[1]` genes are used for the analysis. 

Following is the distribution of biotypes
`r kable(pct.pc)`

### Outlier analysis
Detect outlier samples based on their expression (logCPM) pattern
```{r detect.outliers, fig.height=8, fig.width=8, results='asis', cache = FALSE}
indToRemove = c('MSSM_RNA_ACC_BP_24', 'MSSM_RNA_ACC_375', 'MSSM_RNA_ACC_170', 'MSSM_RNA_ACC_315', 'MSSM_RNA_ACC_250',
                'MSSM_RNA_ACC_21', 'MSSM_RNA_ACC_356', 'MSSM_RNA_ACC_318', 'MSSM_RNA_ACC_222', 'MSSM_RNA_ACC_220',
                'MSSM_RNA_ACC_379', 'MSSM_RNA_PFC_133', 'MSSM_RNA_PFC_139', 'MSSM_RNA_PFC_163', 'MSSM_RNA_PFC_260',
                'MSSM_RNA_PFC_299', 'MSSM_RNA_PFC_361', 'MSSM_RNA_PFC_89', 'MSSM_RNA_PFC_319', 'MSSM_RNA_PFC_348',
                'MSSM_RNA_PFC_354', 'MSSM_RNA_PFC_60', 'PENN_RNA_PFC_71', 'PENN_RNA_PFC_56',  "MSSM_RNA_ACC_310",
                "MSSM_RNA_ACC_51",  "MSSM_RNA_ACC_254", "MSSM_RNA_ACC_28", "MSSM_RNA_ACC_293", "MSSM_RNA_ACC_233",
                "MSSM_RNA_ACC_167", "MSSM_RNA_ACC_353", "MSSM_RNA_ACC_355", "MSSM_RNA_ACC_211", "PENN_RNA_ACC_122",
                "PENN_RNA_ACC_049", "PENN_RNA_ACC_052", "PENN_RNA_ACC_068", "PENN_RNA_ACC_070", "PITT_RNA_ACC_10020",
                "PITT_RNA_ACC_1240", "PITT_RNA_ACC_1284", "PITT_RNA_ACC_700", "PITT_RNA_ACC_857", "PITT_RNA_ACC_BP_1589",
                "MSSM_RNA_PFC_230", "MSSM_RNA_PFC_304", "MSSM_RNA_PFC_309", "MSSM_RNA_PFC_329", "MSSM_RNA_PFC_82",
                "PENN_RNA_PFC_5", "PENN_RNA_PFC_58", "PENN_RNA_PFC_99", "PITT_RNA_PFC_1284")
indToRemove = c(indToRemove, c("MSSM_RNA_ACC_224", "MSSM_RNA_ACC_240", "MSSM_RNA_ACC_BP_11", "MSSM_RNA_ACC_42", "MSSM_RNA_ACC_BP_15", "PENN_RNA_ACC_003", "MSSM_RNA_ACC_374"))
indToRemove = c(indToRemove, "PITT_RNA_BP_PFC_1770")
# Find principal components of expression to plot
PC <- prcomp(voom(PROCESSED_COUNTS$filteredExprMatrix$counts)$E, scale.=T, center = T)
# Plot first 2 PCs
plotdata <- data.frame(SampleID=rownames(PC$rotation), 
                       PC1=PC$rotation[,1], 
                       PC2=PC$rotation[,2])
plotdata <- left_join(plotdata, rownameToFirstColumn(COVARIATES, 'SampleID')) %>%
  tidyr::separate(Dx.Tissue, c('Dx','Tissue'), sep = '_') %>%
  dplyr::mutate(label = SampleID)
plotdata$label[!(plotdata$SampleID %in% indToRemove)] = ''
p <- ggplot(plotdata, aes(x=PC1, y=PC2))
p <- p + geom_point(aes(color=Institution, shape=Tissue, size=Age_of_Death))
p <- p + theme_bw() + theme(legend.position="right") + facet_grid(Tissue~.)
p <- p + geom_text(aes(label= label), size=4, hjust=0)
p
# Plot abberent distribution of logcpm counts
tmp1 = voom(PROCESSED_COUNTS$filteredExprMatrix$counts)$E %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  tidyr::gather(SampleID, logCPM, -ensembl_gene_id) %>%
  left_join(COVARIATES %>%
              rownameToFirstColumn('SampleID') %>%
              tidyr::separate(Dx.Tissue, c('Dx', 'Tissue'), sep = '_'))
p = ggplot(tmp1 %>%
             dplyr::filter(SampleID %in% indToRemove),
           aes(x = logCPM, color = SampleID)) + geom_density() 
p = p + theme(legend.position = 'top') + facet_grid(Dx+.~Tissue, scale = 'free')
p
indToRetain = setdiff(colnames(PROCESSED_COUNTS$filteredExprMatrix$counts), indToRemove)
PROCESSED_COUNTS$filteredExprMatrix$counts = PROCESSED_COUNTS$filteredExprMatrix$counts[,indToRetain]
COVARIATES = COVARIATES[indToRetain,]
tmp = tidyr::separate(COVARIATES, Dx.Tissue, c('Dx', 'Tissue'), sep = '_') %>%
  group_by(Dx, Tissue) %>%
  summarise(count = n()) %>%
  spread(Tissue, count)
```
Processing `r dim(PROCESSED_COUNTS$filteredExprMatrix)[1]` genes in `r dim(PROCESSED_COUNTS$filteredExprMatrix)[2]` samples from `r length(unique(COVARIATES$Individual_ID))` unique individuals

Based on the expression pattern following samples were tagged as outliers: `r paste(indToRemove, collapse = ', ')` 

Distribution of samples are:
`r kable(tmp)`

### Winsorise counts (Gene outliers in samples)
```{r winsorise.data}
LOG.CPM = cpm(PROCESSED_COUNTS$filteredExprMatrix$counts, log = T)
# Set gene counts in specific samples that are deviating 3 sd from other samples to 3SD limit
LOG.CPM = apply(LOG.CPM, 1, function(x){
  mn = mean(x, na.rm = T)
  std.dev = sd(x, na.rm = T)
  
  ind.low = which(x == max(x[which(x <= mn-3*std.dev)], na.rm = T))
  ind.high = which(x == min(x[which(x >= mn+3*std.dev)], na.rm = T))
  
  x[x < (mn-3*std.dev)] = NA
  x[x > (mn+3*std.dev)] = NA
  return(x)
}) %>% t
# Back calculate counts for further analysis
NEW.COUNTS = PROCESSED_COUNTS$filteredExprMatrix$counts
NEW.COUNTS[is.na(LOG.CPM)] = 0
```

### Library Normalisation
Initial library normalisation usign cqn
```{r cqn}
# Compute offset for gene length and gc content
gene_lengths = tibble::column_to_rownames(gene_lengths, var = 'gene_id') %>% as.data.frame()
CQN.GENE_EXPRESSION = cqn(NEW.COUNTS, 
                          x = GENE.GC.CONT[PROCESSED_COUNTS$filteredExprMatrix$genes$genes, 'percentage_gene_gc_content'],
                          lengths = gene_lengths[PROCESSED_COUNTS$filteredExprMatrix$genes$genes, 'Length'],
                          lengthMethod = "smooth", 
                          verbose = FALSE)
CQN.GENE_EXPRESSION$E = CQN.GENE_EXPRESSION$y + CQN.GENE_EXPRESSION$offset
# Set gene counts in specific samples that are deviating 3 sd from other samples to 0
log.mat = apply(CQN.GENE_EXPRESSION$E, 1, function(x){
  mn = mean(x, na.rm = T)
  std.dev = sd(x, na.rm = T)
  return((x < (mn-3*std.dev)) | (x > (mn+3*std.dev)))
}) %>% t
NEW.COUNTS[log.mat] = NA
CQN.GENE_EXPRESSION$E[log.mat] = NA
```

### Co-expression distribution
Coexpression of genes 
```{r coexp1, cache=FALSE, fig.height=5, fig.width=5}
tmp = CQN.GENE_EXPRESSION$E
tmp[is.na(tmp)] = 0
cr = cor(t(tmp))
hist(cr, main = 'Distribution of correlation between genes', xlab = 'Correlation')
```

### Sample clustering
```{r decompse.normalise.data, fig.height=8, fig.width=8, results='asis', cache=FALSE}
# Find principal components of expression to plot
tmp = CQN.GENE_EXPRESSION$E
tmp[is.na(tmp)] = 0
PC <- prcomp(tmp, scale.=T, center = T)
# Plot first 2 PCs
plotdata <- data.frame(SampleID=rownames(PC$rotation), 
                       PC1=PC$rotation[,1], 
                       PC2=PC$rotation[,2])
plotdata <- left_join(plotdata, rownameToFirstColumn(COVARIATES, 'SampleID')) %>%
  tidyr::separate(Dx.Tissue, c('Dx','Tissue'), sep = '_')
p <- ggplot(plotdata, aes(x=PC1, y=PC2))
p <- p + geom_point(aes(color=Institution, shape=Tissue, size=Age_of_Death))
p <- p + theme_bw() + theme(legend.position="right") + facet_grid(Tissue~.)
# p <- p + geom_text(aes(label= SampleID), size=4, hjust=0)
p
```
Tree based clustering of samples
```{r decompse.normalise.data.1, fig.height=6, fig.width=10, results='asis'}
# Eucledian tree based analysis
COVARIATES.tmp = data.matrix(COVARIATES[,c("Institution", "Reported_Gender", "LibraryBatch", "Dx.Tissue")])
COVARIATES.tmp[is.na(COVARIATES.tmp)] = 0
tmp = CQN.GENE_EXPRESSION$E
tmp[is.na(tmp)] = 0
tree = hclust(as.dist(t(tmp)))
cols = WGCNA::labels2colors(COVARIATES.tmp);
WGCNA::plotDendroAndColors(tree, 
                           colors = cols, 
                           dendroLabels = FALSE, 
                           abHeight = 0.80, 
                           main = "Sample dendrogram",
                           groupLabels = colnames(COVARIATES.tmp))
```
```{r temp, include = F}
dev.off()
gc()
```

### Distribution of samples (log cpm)
```{r lcpm.dist, cache=FALSE}
# Plot abberent distribution of logcpm counts
tmp1 = (CQN.GENE_EXPRESSION$E) %>%
  rownameToFirstColumn('gene_id') %>%
  tidyr::gather(SampleID, logCPM, -gene_id) %>%
  left_join(COVARIATES %>%
              rownameToFirstColumn('SampleID'))
p = ggplot(tmp1, aes(x = logCPM, color = SampleID)) + geom_density() 
p = p + theme_bw() %+replace% theme(legend.position = 'NONE') + facet_grid(.~Dx.Tissue, scale = 'free')
p
```

### Significant Covariates
Correlation between pca of unadjusted mRNA expression and covariates is used to find significant covariates
```{r preAdjusted.covariates, cache=TRUE}
# Find correlation between PC's of gene expression with covariates
tmp = CQN.GENE_EXPRESSION$E
tmp[is.na(tmp)] = 0
preAdjustedSigCovars = runPCAandPlotCorrelations(tmp, 
                                                 COVARIATES,
                                                 'NULL design(voom-normalized)', 
                                                 isKeyPlot=TRUE, 
                                                 MIN_PVE_PCT_PC = 1)
```

Significant covariates to adjust at FDR 0.1 are `r preAdjustedSigCovars$significantCovars`
```{r preAdjustedSigCovars.NULL, fig.width=20, fig.height=12}
preAdjustedSigCovars[["PC_res"]][[2]]$plotData
```

### Model Identification
```{r fxn}
# Function to fit a mixed effect model and return BIC
fitMixedEffectModel <- function(varsToFit, groupingVar, lcpm, cnt, covars){
  
  # Get design matrix
  designMat = getDesignMatrix(covars[colnames(lcpm), varsToFit, drop=F], Intercept = F)
  designMat = designMat$design[,linColumnFinder(designMat$design)$indepCols]
  
  # Estimate voom weights
  cnt[is.na(cnt)] = 0
  voomWeights = limma::voom(cnt, design = designMat, plot=F)$weights
  
  modelBIC = foreach::foreach(i = 1:dim(lcpm)[1],
                              .combine = rbind,
                              .packages = c('lme4', 'dplyr'),
                              .export = c('voomWeights')) %dopar% {
                                
                                # Perform weighted mixed linear models for every gene
                                expr = data.frame(Gx = lcpm[i,])
                                data = cbind(expr,
                                             designMat[rownames(expr),],
                                             Individual_ID = groupingVar)
                                formula = paste(setdiff(colnames(data), c('Gx', 'Individual_ID')), collapse = '+') %>%
                                  paste('Gx ~',.,'+ (1|Individual_ID)', collapse = ' ')
                              
                                weights = voomWeights[i,]
                                BIC = NA
                                tryCatch({
                                  mdl = lmer(formula = formula, 
                                             data = data, 
                                             weights = weights)
                                  BIC = BIC(mdl)
                                }, error = function(e){
                                  BIC = NA
                                })
                              return(data.frame(ensembl_gene_id = rownames(lcpm)[i],
                                                BIC = BIC))
                            }
  return(modelBIC)
  }
# Function to select covariates in a step-wise regression fashion
selectCovarsToAdjust <- function(covarsToSelect, adjustCovars, covars, lcpm, cnt, baseModelBIC){
  
  varsSelected = c()
  pkgs = c('CovariateAnalysis', 'data.table', 'dplyr', 'plyr',
           'edgeR', 'limma', 'lme4', 'foreach', 'doParallel')
  while(length(covarsToSelect) != 0){
    allModelBIC = foreach(i = 1:length(covarsToSelect),
                          .combine = c,
                          .packages = pkgs,
                          .export = c('fitMixedEffectModel')) %dopar% {
                            
                            # Fit a mixed effect linear model and get all BIC
                            modelBIC = fitMixedEffectModel(c(adjustCovars, covarsToSelect[i]),
                                                           covars[colnames(cnt),'Individual_ID'], 
                                                           lcpm, 
                                                           cnt, 
                                                           covars) %>%
                            plyr::rename(c('BIC' = covarsToSelect[i]))
                              
                            return(list(modelBIC))
                          }
    allModelBIC = plyr::join_all(allModelBIC) 
    
    # Find number of genes that are changed based on BIC
    nChange = allModelBIC %>%
      tidyr::gather(ModelName, Value, -ensembl_gene_id) %>%
      dplyr::left_join(baseModelBIC) %>%
      dplyr::mutate(diff = baseModel - Value) %>%
      dplyr::group_by(ModelName) %>%
      dplyr::summarise(better = sum(diff >= 5), 
                       worse = sum(diff <= -5)) %>%
      dplyr::mutate(nchange = better - worse)
    
    print(nChange)
    
    # Select variable
    tmp = nChange %>%
      dplyr::filter(nchange > round(dim(cnt)[1]*0.01)) %>%
      dplyr::top_n(1, nchange)
    
    if (dim(tmp)[1] == 0){
      covarsToSelect = c()
    } else {
      baseModelBIC = allModelBIC %>%
        dplyr::select(ensembl_gene_id, one_of(tmp$ModelName))
      colnames(baseModelBIC)[2] = 'baseModel'
      varsSelected = c(varsSelected, tmp$ModelName)
      covarsToSelect = setdiff(covarsToSelect, tmp$ModelName)
      print(paste('Variable chosen to be added:',tmp$ModelName))
    }
  }
  
  return(varsSelected)
}
```
#### Phase I (clinical, ancestry and sample specific technical variables)
```{r phase1}
# Fit a base model with the following covariates
adjust.covars = c('Dx.Tissue')
baseModelBIC = fitMixedEffectModel(adjust.covars, 
                                   COVARIATES[colnames(NEW.COUNTS),'Individual_ID'], 
                                   CQN.GENE_EXPRESSION$E, 
                                   NEW.COUNTS, 
                                   COVARIATES) %>%
  dplyr::rename(baseModel = BIC)
# Iteratively identify covariates in phase I
#_# Add in Dx
phase1.covars = c('Institution', 'Reported_Gender', 'PMI', 'Age_of_Death', 'Dx', 'RIN', 'RIN2', 'EV.1', 'EV.2', 'EV.3', 'EV.4', 'EV.5')
vars.selected = selectCovarsToAdjust(phase1.covars, adjust.covars, 
                                     COVARIATES, CQN.GENE_EXPRESSION$E, 
                                     NEW.COUNTS, baseModelBIC)
adjust.covars = c(adjust.covars, vars.selected)
```
Clinical and technical variables selected in phase I are `r paste(adjust.covars, collapse = ', ')`

#### Phase II (batch effects)
```{r phase2}
# Fit a base model with the following covariates
baseModelBIC = fitMixedEffectModel(adjust.covars, 
                                   COVARIATES[colnames(NEW.COUNTS),'Individual_ID'], 
                                   CQN.GENE_EXPRESSION$E, 
                                   NEW.COUNTS, 
                                   COVARIATES) %>%
  dplyr::rename(baseModel = BIC)
# Iteratively identify covariates in phase I
phase2.covars = c('LibraryBatch', 'FlowcellBatch')
vars.selected = selectCovarsToAdjust(phase2.covars, adjust.covars, 
                                     COVARIATES, CQN.GENE_EXPRESSION$E, 
                                     NEW.COUNTS, baseModelBIC)
adjust.covars = c(adjust.covars, vars.selected)
```
Clinical, technical and batch variables selected after phase I and II of model identification are `r paste(adjust.covars, collapse = ', ')`

#### Phase III (RNASeq alignment specific covariates)
```{r phase3}
# Fit a base model with the following covariates
baseModelBIC = fitMixedEffectModel(adjust.covars, 
                                   COVARIATES[colnames(NEW.COUNTS),'Individual_ID'], 
                                   CQN.GENE_EXPRESSION$E, 
                                   NEW.COUNTS, 
                                   COVARIATES) %>%
  dplyr::rename(baseModel = BIC)
# Iteratively identify covariates in phase I
phase3.covars = c("MappedReads", "IntragenicRate", "IntronicRate", "IntergenicRate", "GenesDetected", "rRNARate", "TotalReads")
vars.selected = selectCovarsToAdjust(phase3.covars, adjust.covars, 
                                     COVARIATES, CQN.GENE_EXPRESSION$E, 
                                     NEW.COUNTS, baseModelBIC)
adjust.covars = c(adjust.covars, vars.selected)
```
Clinical, technical and batch variables selected after phase I, II and III of model identification are `r paste(adjust.covars, collapse = ', ')`

### Normalisation
1. Dx.Tissue is chosen as the primary variable of interest (i.e., covariate adjustments is conditioned on diagnosis and tissue)
2. Individual_ID is chosen as random effect
```{r iterative.normalisation, results='asis'}
writeLines(paste('Using following covariates in the model:',
                 paste(adjust.covars, collapse=', '),
                 'as fixed effects and Individual_ID is chosen as random effect'))
  
# Post adjusted design matrix
DM1 = getDesignMatrix(COVARIATES[,adjust.covars,drop=F],Intercept = F)
DM1$design = DM1$design[,linColumnFinder(DM1$design)$indepCols]
  
# Estimate voom weights
tmp = NEW.COUNTS
tmp[is.na(tmp)] = 0
VOOM.GENE_EXPRESSION = voom(tmp, design=DM1$design, plot=F)
# Estimate consensus correlation coefficient
correlation <- parallelDuplicateCorrelation(VOOM.GENE_EXPRESSION, block = COVARIATES$Individual_ID)
  
# Re-calculate voom weights with correlation of random effects
VOOM.GENE_EXPRESSION = voom(tmp, 
                            design=DM1$design, plot=F,
                            block = COVARIATES$Individual_ID, 
                            correlation = correlation$cor)
# Fit linear model using new weights and new design
VOOM.GENE_EXPRESSION$E = CQN.GENE_EXPRESSION$E
ADJUSTED.FIT = lmFit(VOOM.GENE_EXPRESSION)
  
# Residuals after normalisation
RESIDUAL.GENE_EXPRESSION = residuals.MArrayLM(ADJUSTED.FIT, CQN.GENE_EXPRESSION$E)
# Find PC of residual gene expression and significant covariates that are highly correlated with PCs
tmp = RESIDUAL.GENE_EXPRESSION
tmp[is.na(tmp)] = 0
residualSigCovars = runPCAandPlotCorrelations(tmp, COVARIATES,
                                              'adjusted design(voom-normalized)',
                                              isKeyPlot=TRUE)
```

### Sanity check
```{r residualSigCovars.manual, fig.width=12, fig.height=8}
residualSigCovars[["PC_res"]][[2]]$plotData
```

### Residual calculation
Calculate weighted residuals and add back "Dx.Tissue" to the residuals
```{r varsToAddBack}
# Add variable of interest back to the residuals
varsToAddIn = grep("Dx.Tissue", colnames(DM1$design), value = T)
RESIDUAL.GENE_EXPRESSION = RESIDUAL.GENE_EXPRESSION +
  ADJUSTED.FIT$coefficients[,varsToAddIn] %*% t(DM1$design[,varsToAddIn])
```

### Coexpression of residual expression 
```{r coexp2, cache=FALSE, fig.height=5, fig.width=5}
tmp = RESIDUAL.GENE_EXPRESSION
tmp[is.na(tmp)] = 0
cr = cor(t(tmp))
hist(cr, main = 'Distribution of correlation between genes', xlab = 'Correlation')
```

### Clustering residual data
```{r decompse.normalise.data2, fig.height=8, fig.width=8, results='asis'}
# Find principal components of expression to plot
PC <- prcomp(tmp, scale.=T, center = T)
# Plot first 4 PCs
plotdata <- data.frame(SampleID=rownames(PC$rotation), 
                       PC1=PC$rotation[,1], 
                       PC2=PC$rotation[,2])
plotdata <- left_join(plotdata, rownameToFirstColumn(COVARIATES, 'SampleID')) %>%
  tidyr::separate(Dx.Tissue, c('Dx','Tissue'), sep = '_')
p <- ggplot(plotdata, aes(x=PC1, y=PC2))
p <- p + geom_point(aes(color=Institution, shape=Tissue, size=Age_of_Death))
p <- p + theme_bw() + theme(legend.position="right") + facet_grid(Tissue~., scales = 'free_y')
p
```

```{r decompse.normalise.data2.1, fig.height=8, fig.width=12, results='asis'}
# Eucledian tree based analysis
COVARIATES.tmp = data.matrix(COVARIATES[,c('Dx.Tissue','Institution')])
COVARIATES.tmp[is.na(COVARIATES.tmp)] = 0
tree = hclust(as.dist(t(tmp)))
cols = WGCNA::labels2colors(COVARIATES.tmp);
WGCNA::plotDendroAndColors(tree, 
                           colors = cols, 
                           dendroLabels = FALSE, 
                           abHeight = 0.80, 
                           main = "Sample dendrogram",
                           groupLabels = colnames(COVARIATES.tmp[,c('Dx.Tissue','Institution')]))
```

```{r temp1, include=F}
dev.off()
gc()
```

### Differential expression analysis
Genes that are differentially expressed at an FDR <= 0.05 are
```{r diffExp, fig.height=10, fig.width=15}
# Fit contrast
contrast = makeContrasts(contrasts=c("Dx.TissueOther_ACC-Dx.TissueControl_ACC",
                                     "Dx.TissueSCZ_ACC-Dx.TissueControl_ACC",
                                     "Dx.TissueSCZ_ACC-Dx.TissueOther_ACC",
                                     "Dx.TissueOther_DLPFC-Dx.TissueControl_DLPFC",
                                     "Dx.TissueSCZ_DLPFC-Dx.TissueControl_DLPFC",
                                     "Dx.TissueSCZ_DLPFC-Dx.TissueOther_DLPFC"),
                         levels = colnames(ADJUSTED.FIT$coefficients))
FIT.CONTR = contrasts.fit(ADJUSTED.FIT, contrasts=contrast)
FIT.CONTR = eBayes(FIT.CONTR)
# Get differnetial expression
DE = lapply(1:6, function(i, FIT){
  topTable(FIT, coef=i, number = 50000, confint = TRUE) %>%
    rownameToFirstColumn('gene_id') %>% 
    left_join(backgroundGenes)
}, FIT.CONTR) 
names(DE) = colnames(contrast)
DE = DE %>% 
  rbindlist(idcol = 'Comparison') %>%
  dplyr::mutate(Comparison = gsub('Dx.Tissue','',Comparison),
                Direction = logFC/abs(logFC),
                Direction = factor(Direction, c(-1,1), c('-1' = 'DOWN', '1' = 'UP')),
                Direction = as.character(Direction)) %>%
  tidyr::separate(Comparison, into = c('ref.state','to.state'), sep = '-') %>%
  tidyr::separate(ref.state, into = c('Dx1','Tissue'), sep = '_') %>%
  tidyr::separate(to.state, into = c('Dx2','Tissue'), sep = '_') %>%
  tidyr::unite(Comparison, Dx1, Dx2, sep = '_vs_') %>%
  left_join(Ensemble2HGNC) %>%
  left_join(gene_lengths %>% rownameToFirstColumn('gene_id'))
DE$Direction[DE$adj.P.Val > 0.05 | abs(DE$logFC) < log2(1.2)] = 'NONE'
tmp = DE %>%
  dplyr::filter(adj.P.Val <= 0.05) %>%
  dplyr::select(ensembl_gene_id, Comparison, Tissue) %>%
  group_by(Comparison, Tissue) %>%
  dplyr::summarise(FDR_0_05 = length(unique(ensembl_gene_id)))
tmp1 = DE %>%
  dplyr::filter(adj.P.Val <= 0.05, abs(logFC) >= log2(1.2)) %>%
  dplyr::select(ensembl_gene_id, Comparison, Tissue) %>%
  group_by(Comparison, Tissue) %>%
  dplyr::summarise(FDR_0_05_FC_1.2 = length(unique(ensembl_gene_id)))
kable(full_join(tmp,tmp1))
p = ggplot(DE, aes(y = -log10(adj.P.Val), x = logFC, color = Direction)) + geom_point() + xlim(c(-1,1))
p = p + scale_color_manual(values = c('green','grey','red')) + theme_bw() %+replace% theme(legend.position = 'top')
p = p + facet_grid(Tissue+.~Comparison, scales = 'fixed')
p
```

### Associate differential expression results with gc content, gene length and average expression
```{r associate.de, fig.height=10, fig.width=15}
pl = list()
pl[[1]] = ggplot(DE %>% 
                   arrange(match(Direction, c("NONE", "UP", "DOWN"))), aes(x = log10(Length), y = logFC, color = Direction)) + geom_point() 
pl[[1]] = pl[[1]] + geom_smooth(method = 'loess', inherit.aes = FALSE, aes(x = log10(Length), y = logFC))
pl[[1]] = pl[[1]] + facet_grid(Comparison~.) + scale_color_manual(values = c('green','grey','red'))
pl[[1]] = pl[[1]] + theme(legend.position = 'top')
pl[[2]] = ggplot(DE %>% 
                   arrange(match(Direction, c("NONE", "UP", "DOWN"))), aes(x = percentage_gene_gc_content, y = logFC, color = Direction)) + geom_point()
pl[[2]] = pl[[2]] + geom_smooth(method = 'loess', inherit.aes = FALSE, aes(x = percentage_gene_gc_content, y = logFC))
pl[[2]] = pl[[2]] + facet_grid(Comparison~.) + scale_color_manual(values = c('green','grey','red'))
pl[[2]] = pl[[2]] + theme(legend.position = 'top')
pl[[3]] = ggplot(DE %>% 
                    arrange(match(Direction, c("NONE", "UP", "DOWN"))), aes(x = AveExpr, y = logFC, color = Direction)) + geom_point()
pl[[3]] = pl[[3]] + geom_smooth(method = 'loess', inherit.aes = FALSE, aes(x = AveExpr, y = logFC))
pl[[3]] = pl[[3]] + facet_grid(Comparison~.) + scale_color_manual(values = c('green','grey','red'))
pl[[3]] = pl[[3]] + theme(legend.position = 'top')
multiplot(plotlist = pl, cols = 3)
```

### Gene set enrichment analysis
Using Fisher's exact test for gene set enrichment analysis
```{r enrich.de, fig.height=16, fig.width=16}
diffexp.genes = DE %>%
  dlply(.(Comparison, Tissue), .fun = function(x){
    tmp = x$hgnc_symbol[x$adj.P.Val <= 0.05] %>% unique
    tmp = tmp[!is.na(tmp)]
  })
diffexp.genes = diffexp.genes[sapply(diffexp.genes, length) > 20]
backgroundGenes = unique(DE$hgnc_symbol)
# Download all related genesets from synapse
geneset.files = synGetChildren("syn3240583", includeTypes=list("file"))$asList()
genesets.to.test = purrr::map(geneset.files, .f = function(fileList){
  tmp = downloadFile(fileList$id) %>%
    dlply(.(Name), .fun = function(x){
      str_split(x$symBeforeOverlap, '\\|') %>% unlist %>% unique
    })
  }) %>%
  CovariateAnalysis::filterGeneSets(backgroundGenes) %>%
  do.call(c,.)
# Perform enrichment analysis
enrichment.results = llply(diffexp.genes, .fun = function(x, genesetsToTest, backgroundGenes){
   ldply(genesetsToTest, .fun = function(y,x,backgroundGenes){
     CovariateAnalysis::fisherEnrichment(x, y, backgroundGenes)
    }, x, backgroundGenes, .parallel = TRUE) %>%
    dplyr::mutate(fdr = p.adjust(pval, method = 'fdr'))
}, genesets.to.test, backgroundGenes) %>%
  rbindlist(idcol = 'Comparison', use.names = T, fill = T) %>%
  tidyr::separate(Comparison, c('Name', 'Region'), sep = '\\.') %>%
  dplyr::rename(Comparison = Name, Category = .id)
```

```{r synapse.parameters, include=FALSE, cache=TRUE}
parentId = 'syn9872607';
activityName = 'Covariate adjustments';
activityDescription = 'Covariate analysis of GRCh38 feature counts with CQN normalisation (ACC and DLPFC)';
thisFileName <- 'MSSM-Penn-Pitt_ACC_DLPFC_FEATURECOUNTS_GRCh38_CQN_Sparse.Rmd'
# Github link
thisRepo <- githubr::getRepo(repository = "jgockley62/TWAS", ref="branch", refName='master')
thisFile <- githubr::getPermlink(repository = thisRepo, repositoryPath=paste0('code/',thisFileName))
```

### Store files in synapse
```{r synapse.store, include=FALSE, eval=TRUE, cache=FALSE}
# Set annotations
all.annotations = list(
  dataType = 'geneExpression',
  dataSubtype = 'processed',
  assay	 = 'rnaSeq',
  
  tissue	= 'dorsolateral prefrontal cortex, anterior cingulate cortex', 
  study = 'CMC', 
  species = 'Human',
  consortium	= 'CMC',
   
  analysisType	= "data normalization",
  
  transcriptNormalizationMethod	= 'CQN',
  transcriptQuantificationMethod = 'featureCounts',
  referenceSet = 'GRCh38'
)
# Code
CODE <- Folder(name = "MSSM-Penn-Pitt - ACC and DLPFC - FEATURECOUNTS - GRCh38 - CQN - Sparse Model", parentId = parentId)
CODE <- synStore(CODE)
# Store covariates
COVARIATES = rownameToFirstColumn(COVARIATES, 'SampleID')
write.table(COVARIATES, file = 'CMC_ACC_DLPFC_Covariates.tsv', sep = '\t', row.names=F, quote=F)
COV_OBJ = synapser::File('CMC_ACC_DLPFC_Covariates.tsv', name = 'Covariates', parentId = CODE$properties$id)
COV_OBJ = synStore(COV_OBJ, used = ALL_USED_IDs, activityName = activityName, 
                      executed = thisFile, activityDescription = activityDescription)
synSetAnnotations(COV_OBJ, annotations = all.annotations)
# Store filtered counts
PROCESSED_COUNTS$filteredExprMatrix$counts %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  write.table(file = 'CMC_ACC_DLPFC_Counts.tsv', sep = '\t', row.names=F, quote=F)
COUNT_OBJ = File('CMC_ACC_DLPFC_Counts.tsv', name = 'Counts (filtered raw)', parentId = CODE$properties$id)
COUNT_OBJ = synStore(COUNT_OBJ, activity = synGetActivity(COV_OBJ$properties$id))
synSetAnnotations(COUNT_OBJ, annotations = all.annotations)
# Store logCPM
CQN.GENE_EXPRESSION$E %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  write.table(file = 'CMC_ACC_DLPFC_logCPM.tsv', sep = '\t', row.names=F, quote=F)
LCOUNT_OBJ = File('CMC_ACC_DLPFC_logCPM.tsv', name = 'Counts (filtered logCPM)', parentId = CODE$properties$id)
LCOUNT_OBJ = synStore(LCOUNT_OBJ, used = ALL_USED_IDs, activityName = activityName, 
                      executed = thisFile, activityDescription = activityDescription)
synSetAnnotations(LCOUNT_OBJ, annotations = all.annotations)
# Store cqn offsets
CQN.GENE_EXPRESSION$offset %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  write.table(file = 'CMC_ACC_DLPFC_offset.tsv', sep = '\t', row.names=F, quote=F)
OFFSET_OBJ = File('CMC_ACC_DLPFC_offset.tsv', name = 'Gene length and GC content offset', parentId = CODE$properties$id)
OFFSET_OBJ = synStore(OFFSET_OBJ, used = ALL_USED_IDs, activityName = activityName, 
                      executed = thisFile, activityDescription = activityDescription)
synSetAnnotations(OFFSET_OBJ, annotations = all.annotations)
# Store design matrix
DM1$design %>%
  rownameToFirstColumn('SampleID') %>%
  write.table(file = 'CMC_ACC_DLPFC_Design.tsv', sep = '\t', row.names=F, quote=F)
DM_OBJ = File('CMC_ACC_DLPFC_Design.tsv', name = 'Design Matrix', parentId = CODE$properties$id)
DM_OBJ = synStore(DM_OBJ, used = ALL_USED_IDs, activityName = activityName, 
                  executed = thisFile, activityDescription = activityDescription)
synSetAnnotations(DM_OBJ, annotations = all.annotations)
# Store residual gene expression for network analysis
RESIDUAL.GENE_EXPRESSION %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  write.table(file = 'CMC_ACC_DLPFC_netResidualExpression.tsv', sep = '\t', row.names=F, quote=F)
nEXP_OBJ = File('CMC_ACC_DLPFC_netResidualExpression.tsv', 
                name = 'Normalised, covariates removed residual expression (for network analysis)', 
                parentId = CODE$properties$id)
nEXP_OBJ = synStore(nEXP_OBJ, used = ALL_USED_IDs, activityName = activityName, 
                    executed = thisFile, activityDescription = activityDescription)
synSetAnnotations(nEXP_OBJ, annotations = all.annotations)
# Store differential expression results
write.table(DE, file = 'CMC_ACC_DLPFC_DiffExpression.tsv', sep = '\t', row.names=F, quote=F)
DEXP_OBJ = File('CMC_ACC_DLPFC_DiffExpression.tsv', 
                name = 'Differential Expression Results (Dx.Tissue)', 
                parentId = CODE$properties$id)
DEXP_OBJ = synStore(DEXP_OBJ, used = ALL_USED_IDs, activityName = activityName, 
                    executed = thisFile, activityDescription = activityDescription)
synSetAnnotations(DEXP_OBJ, annotations = all.annotations)
# Store enrichment results
write.table(enrichment.results, file = 'CMC_ACC_DLPFC_EnrichResults.tsv', sep = '\t', row.names=F, quote=F)
ENRICH_OBJ = File('CMC_ACC_DLPFC_EnrichResults.tsv', 
                  name = 'Enrichment Analysis Results (Dx.Tissue)', 
                  parentId = CODE$properties$id)
ENRICH_OBJ = synStore(ENRICH_OBJ, used = ALL_USED_IDs, activityName = activityName, 
                      executed = thisFile, activityDescription = activityDescription)
synSetAnnotations(ENRICH_OBJ, annotations = all.annotations)
```

```{r knit2synapse, eval=FALSE}
synapseclient <- reticulate::import("synapseclient")
syn_temp <- synapseclient$Synapse()
syn_temp$login()

setwd("~/TWAS/code/")
source("~/TWAS/utilityFunctions/knitfile2synapseClient.R")
source("~/TWAS/utilityFunctions/hook_synapseMdSyntax_plot.R")

createAndKnitToFolderEntityClient(file = "MSSM-Penn-Pitt_ACC_DLPFC_FEATURECOUNTS_GRCh38_CQN_Sparse.Rmd",
                                 parentId ="",
                                 folderName = "MSSM-Penn-Pitt - ACC and DLPFC - FEATURECOUNTS - GRCh38 - CQN - Sparse Model")
```


```
|  *Results*                                  |  *SynapseID*                     |
|  -----------------------------------------  |   ---------                      |
|  Covariates                                 |  `r COV_OBJ$properties$id`       |
|  Counts (raw)                               |  `r COUNT_OBJ$properties$id`     |
|  Counts (lcpm)                              |  `r LCOUNT_OBJ$properties$id`    |
|  Offset (for gene length and gc content)    |  `r OFFSET_OBJ$properties$id`    |
|  Design Matrix                              |  `r DM_OBJ$properties$id`        |
|  Residual Expression (for network analysis) |  `r nEXP_OBJ$properties$id`      |
|  Differential Expression                    |  `r DEXP_OBJ$properties$id`      |
|  Enrichment Analysis                        |  `r ENRICH_OBJ$properties$id`    |
### Source Rmd
[Source markdown](`r thisFile`)