---
title: "MSSM-Penn-Pitt - ACC and DLPFC - FEATURECOUNTS - GRCh38 - CQN - Iterative Model"
author: "Addapted from Kelsey Montgomery"
date: "11/8/2019"
output: html_document
---

Date of analysis update: "`r date()`"

```{r libs, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE, cache=FALSE}
##It is assumed your working directory is "~/ampad-DiffExp/gene_level_analysis"
## Load required libraries
library(CovariateAnalysis) # get the package from devtools::install_github('th1vairam/CovariateAnalysis@dev')
library(data.table)
library(plyr)
library(tidyverse)
library(psych)
library(stringr)
library(limma)
library(edgeR)
library(biomaRt)
library(RColorBrewer)
library(cqn)
library(glmnet)
library(githubr) # get the package from devtools::install_github('brian-bot/githubr')
library(knitr)
library(doParallel)
library(foreach)
library(sva)
#library(reticulate)
library(R.utils)
library(data.table)

cl = makeCluster(detectCores()-2)
registerDoParallel(cl)
options(xtable.type="html")
# Source modified utility functions from limma and sva package
source('~/TWAS/utilityFunctions/parallelDuplicateCorrelation.R')
source('~/TWAS/utilityFunctions/irwsva.build.R')
source('~/TWAS/utilityFunctions/f.pvalue.R')
knitr::opts_chunk$set(
  echo=FALSE,
  warning=FALSE,
  message=FALSE,
  error = FALSE,
  tidy = FALSE,
  cache = TRUE)
```

### Data download
#### Obtain count matrix and metadata from synapse.
```{r download.data, cache=TRUE}
downloadFile <- function(id){
  fread(syn_temp$get(id)$path, data.table = F)
}
downloadFile_version <- function(id , version){
  fread(syn_temp$get(id, version = version)$path, data.table = F)
}
# Download reprocessed counts
CountDwnld <- function( ID ){
  counts = ID
  counts = downloadFile(counts) %>% data.frame()
  #_# Fix  Row Names of Counts
  counts$Chr <- NULL
  counts$Start <- NULL
  counts$End <- NULL
  counts$Strand <- NULL
  row.names(counts) <- counts$Geneid #  do.call( rbind, strsplit(counts$Geneid,"[.]") )[,1]
  return( counts )
}
#_Deprecated_# counts = 'syn21071622'
#ACC:
ACC_counts <- CountDwnld( 'syn16783557' )
#PFC:
DLPFC_counts = CountDwnld( 'syn16783508' )
ALL_USED_IDs = c('syn16783557','syn16783508')

if( all( row.names(ACC_counts) %in% row.names(DLPFC_counts) ) ){
  gene_lengths = ACC_counts[,c("Geneid", "Length")]
  ACC_counts$Length <- NULL
  DLPFC_counts$Length <- NULL
  gene_lengths <- rename(gene_lengths, gene_id = Geneid)
  counts <- merge(ACC_counts, DLPFC_counts[,colnames(DLPFC_counts) != 'Geneid'], by=0)
}else{
  warning('Expression Rows not equal')
}

#row.names(counts) <- counts$Geneid #  do.call( rbind, strsplit(counts$Geneid,"[.]") )[,1]

# Parse gene lengths

# Get ancestry vector calculated using gemtools
ANCESTRY_ID = 'syn2511399'
ALL_USED_IDs[length(ALL_USED_IDs)+1] = ANCESTRY_ID
ANCESTRY = downloadFile(ANCESTRY_ID) %>% 
  plyr::rename(c('DNA_report..Genotyping.Sample_ID' = 'SNP_report:Genotyping_Sample_ID'))
# Get genotype ids from synapse
GENOTYPE_ID = 'syn16816490'
ALL_USED_IDs = c(ALL_USED_IDs, GENOTYPE_ID)
GENOTYPE = downloadFile(GENOTYPE_ID) %>% 
  dplyr::select(Individual_ID, `SNP_report:Genotyping_Sample_ID`) %>%
  dplyr::inner_join(ANCESTRY)
#Get Metadata
#--syn16783596

metadata = 'syn16816488' 
ALL_USED_IDs[length(ALL_USED_IDs)+1] = metadata
metadata = downloadFile_version(metadata, version = 13)  %>% 
  dplyr::select(Individual_ID, Institution, Reported_Gender, Sex, Ethnicity, Age_of_Death, `PMI_(in_hours)`, Dx,
                Sample_RNA_ID, one_of('rnaSeq_isolation:RIN',
                                      'rnaSeq_report:Ribozero_Batch', 'rnaSeq_report:Library_Batch', 
                                      'rnaSeq_report:Flowcell_Batch','rnaSeq_dissection:Brain_Region',
                                      'rnaSeq_report:Exclude?',
                                      'rnaSeq_report:Mapped_Reads',
                                      'rnaSeq_report:Intragenic_Rate','rnaSeq_report:Intronic_Rate',
                                      'rnaSeq_report:Intergenic_Rate','rnaSeq_report:Genes_Detected',
                                      'rnaSeq_report:Expression_Profiling_Efficiency',
                                      'rnaSeq_report:rRNA_Rate',
                                      'rnaSeq_report:Total_Reads', 'rnaSeq_report:Percent_Aligned'))
METADATA = metadata %>%
  dplyr::left_join(GENOTYPE) %>%
  dplyr::rename(PMI = `PMI_(in_hours)`,
                Sample_ID = Sample_RNA_ID,
                ReportExclude = `rnaSeq_report:Exclude?`,
                SampleID = Sample_RNA_ID,
                LibraryBatch = `rnaSeq_report:Library_Batch`,
                FlowcellBatch = `rnaSeq_report:Flowcell_Batch`,
                RibozeroBatch = `rnaSeq_report:Ribozero_Batch`,
                Tissue = `rnaSeq_dissection:Brain_Region`,
                MappedReads = `rnaSeq_report:Mapped_Reads`,
                IntragenicRate = `rnaSeq_report:Intragenic_Rate`, 
                IntronicRate = `rnaSeq_report:Intronic_Rate`, 
                IntergenicRate = `rnaSeq_report:Intergenic_Rate`, 
                GenesDetected = `rnaSeq_report:Genes_Detected`,
                ExpProfEfficiency = `rnaSeq_report:Expression_Profiling_Efficiency`, 
                rRNARate = `rnaSeq_report:rRNA_Rate`,
                TotalReads = `rnaSeq_report:Total_Reads`, 
                AlignmentRate = `rnaSeq_report:Percent_Aligned`,
                RIN = `rnaSeq_isolation:RIN`) %>%
  dplyr::select(SampleID, Individual_ID, Institution, Reported_Gender,Sex, Ethnicity, Age_of_Death, PMI, Dx, 
                RIN, ReportExclude, EV.1, EV.2, EV.3, EV.4, EV.5,
                LibraryBatch, FlowcellBatch, RibozeroBatch, Tissue, MappedReads, TotalReads, GenesDetected, AlignmentRate,
                IntragenicRate, IntergenicRate, IntronicRate, ExpProfEfficiency, rRNARate) %>% 
  dplyr::filter(Institution %in% c("MSSM", "Penn", "Pitt")) %>% 
  dplyr::filter(SampleID %in% colnames(counts), !is.na(SampleID)) %>%
  dplyr::mutate(Dx = forcats::fct_recode(Dx,  Other = "AFF", Other = "BP", Control = "Control", SCZ = "SCZ"))

#Load this alignments Seq Stats:
AltMeta <- 'syn16783596'
altACC = downloadFile_version(AltMeta, version = 1)
AltMeta <- 'syn16783867'
altPFCC = downloadFile_version(AltMeta, version = 1)
alt <- rbind(altACC, altPFCC)

colnames(alt) <- c('cnt', 'ID', 'TotalReads', 'MappedReads','GenesDetected', 'TranscriptsDetected', 'AlignmentRate', 
                   'IntragenicRate', 'IntronicRate', 'IntergenicRate', 'ExpProfEfficiency', 'rRNARate')

#Get rid of FlowcellBatch
METADATA <- METADATA[ , colnames(METADATA) != 'FlowcellBatch' ]
METADATA <- METADATA[ !duplicated(METADATA),]
row.names(METADATA) <- METADATA$SampleID
row.names(alt) <- alt$ID
METADATA <- METADATA[  row.names(alt), ]

#Now copy in relevant New Seq Stats:
METADATA$MappedReads <- alt[ row.names(METADATA), ]$MappedReads
METADATA$TotalReads <- alt[ row.names(METADATA), ]$TotalReads
METADATA$GenesDetected <- alt[ row.names(METADATA), ]$GenesDetected
METADATA$AlignmentRate <- alt[ row.names(METADATA), ]$AlignmentRate
METADATA$IntragenicRate <- alt[ row.names(METADATA), ]$IntragenicRate
METADATA$IntergenicRate <- alt[ row.names(METADATA), ]$IntergenicRate
METADATA$IntronicRate <- alt[ row.names(METADATA), ]$IntronicRate
METADATA$ExpProfEfficiency <- alt[ row.names(METADATA), ]$ExpProfEfficiency
METADATA$rRNARate <- alt[ row.names(METADATA), ]$rRNARate
```

### Data preprocessing
```{r preprocess.data}
ind = METADATA$SampleID[which(METADATA$ReportExclude == 1)]
writeLines(paste('Following',length(ind),'samples are marked exclude'))
writeLines(paste(ind, collapse = ', '))
METADATA <- METADATA  %>% dplyr::filter(!(SampleID %in% ind)) 
ind = METADATA$SampleID [is.na(METADATA$Ethnicity) | is.na(METADATA$Institution) | is.na(METADATA$Dx)]
writeLines(paste('Following', length(ind), 'counts are missing clinical metadata'))
writeLines(paste(ind, collapse = ', '))
METADATA <- METADATA  %>% dplyr::filter(!(SampleID %in% ind)) 
ind = METADATA$SampleID [is.na(METADATA$PMI)]
writeLines(paste('Following', length(ind), 'counts are missing PMI'))
writeLines(paste(ind, collapse = ', '))
METADATA <- METADATA  %>% dplyr::filter(!(SampleID %in% ind)) 
ind = METADATA$SampleID [is.na(METADATA$Reported_Gender)]
writeLines(paste('Following', length(ind), 'counts are missing gender'))
writeLines(paste(ind, collapse = ', '))
METADATA <- METADATA  %>% dplyr::filter(!(SampleID %in% ind)) 
ind = METADATA$SampleID [is.na(METADATA$Age_of_Death)]
writeLines(paste('Following', length(ind), 'counts are missing age of death'))
writeLines(paste(ind, collapse = ', '))
METADATA <- METADATA  %>% dplyr::filter(!(SampleID %in% ind))
ind = METADATA$SampleID [is.na(METADATA$EV.1)]
writeLines(paste('Following', length(ind), 'counts are missing ancestry information'))
writeLines(paste(ind, collapse = ', '))
METADATA <- METADATA  %>% dplyr::filter(!(SampleID %in% ind))
```

```{r preprocess.data1, results='asis'}
# Match covariates to expression data
indToRetain = intersect(METADATA$SampleID, colnames(counts))
rownames(counts) <- counts$Geneid
counts = counts[,indToRetain]
rownames(METADATA) = METADATA$SampleID
METADATA = METADATA[indToRetain,]
METADATA %>% 
  group_by(Dx, Tissue) %>% 
  summarise(count = n()) %>% 
  spread(Tissue, count) %>%
  kable()
#_# Add in Dx.TissueSource
METADATA = METADATA %>%
  dplyr::mutate(Dx.Tissue = paste(Dx, Tissue, sep = '.')) %>%
  dplyr::mutate(Dx.TissueSource = paste(Dx, Tissue, Institution, sep = '.'))
```


```{r gene.param}
## Get GC content from biomart
backgroundGenes = data.frame(gene_id = rownames(counts)) %>%
  dplyr::mutate(id = gene_id) %>%
  tidyr::separate(id, c('ensembl_gene_id','position'), sep = '\\.')
# Define biomart object
mart <- useMart(biomart = "ENSEMBL_MART_ENSEMBL", host = "jul2019.archive.ensembl.org", dataset = "hsapiens_gene_ensembl")
# Query biomart
Ensemble2HGNC <- getBM(attributes = c("ensembl_gene_id", "hgnc_symbol", "percentage_gene_gc_content", "gene_biotype", "chromosome_name"),
                       filters = "ensembl_gene_id", values = backgroundGenes$ensembl_gene_id,
                       mart = mart)
GENE.GC.CONT = Ensemble2HGNC %>%
  dplyr::left_join(backgroundGenes) %>% 
  dplyr::select(gene_id, percentage_gene_gc_content, chromosome_name) %>%
  unique
rownames(GENE.GC.CONT) = GENE.GC.CONT$gene_id
```

### Sex Check
```{r Reported_Gender_plots}
counts$gene_id = rownames(counts) 
REPORTED.GENDER.COUNTS = GENE.GC.CONT %>% 
  left_join(counts) %>%
  dplyr::select(-one_of("percentage_gene_gc_content")) %>%
  filter(chromosome_name == "X" |chromosome_name == "Y") %>% 
  tidyr::gather(key = item, value = value, -c(gene_id, chromosome_name)) %>%
  mutate(value = log(value)) %>%
  rename(`counts(log)`= value) %>% 
  rename(SampleID = item) %>%
  left_join(METADATA[,c("SampleID", "Reported_Gender")]) %>% 
  rename(`Reported Gender` = Reported_Gender) 
##XIST and UTY expression 
#ENSG00000229807.10 and ENSG00000183878.15 
#ENSG00000229807.11
FILT <- REPORTED.GENDER.COUNTS %>% 
  #_#filter(gene_id == "ENSG00000229807.11" | gene_id == "ENSG00000183878.15") %>% 
  filter(gene_id == "ENSG00000229807.10" | gene_id == "ENSG00000183878.15") %>% 
  dplyr::select(-one_of("chromosome_name")) %>% 
  tidyr::spread(key = gene_id, value = `counts(log)`) %>% 
  #_#mutate(XIST = as.numeric(`ENSG00000229807.11`)) %>% 
  mutate(XIST = as.numeric(`ENSG00000229807.10`)) %>% 
  mutate(UTY = as.numeric(`ENSG00000183878.15`))
p = ggplot(FILT, aes (x= XIST, y = UTY)) 
p = p + geom_point(aes(color=`Reported Gender`)) 
p
```

### Covariate clustering
Determine relationship between covariates
```{r covariates.clustering}
#primaryVariable <- c("Tissue.SourceDiagnosis", "Tissue.Diagnosis", "Tissue.APOE4")
primaryVariable <- c("Dx.TissueSource", "Dx.Tissue")
#_# ADD DIAGNOSIS HERE TO REGRESS FOR TWAS
#_#Removed 'FlowCellBatch' and FactorCovariates
FactorCovariates <- c('Individual_ID', "Institution", "Reported_Gender", "LibraryBatch", "Dx.Tissue", "Dx", "RibozeroBatch")
#_#FactorCovariates <- c('Individual_ID', "Institution","Dx.Tissue", "Reported_Gender", "Dx", "RibozeroBatch")
ContCovariates <- c("Age_of_Death", "PMI", "RIN", "MappedReads", "IntragenicRate", "IntronicRate", "IntergenicRate", "GenesDetected", "ExpProfEfficiency", "rRNARate", "TotalReads","AlignmentRate", "EV.1", "EV.2", "EV.3", "EV.4", "EV.5")

#METADATA <- METADATA[ METADATA$Tissue == 'DLPFC', ]
#counts <- counts[ , METADATA$SampleID]

# Find inter relation between factor covariates
METADATA <- METADATA[ !duplicated(METADATA), ]
COVARIATES = METADATA[,c(FactorCovariates,ContCovariates),drop=F]
rownames(COVARIATES) <- METADATA$ID
# Convert factor covariates to factors
COVARIATES[,FactorCovariates] = lapply(COVARIATES[,FactorCovariates], factor)
COVARIATES[,ContCovariates] = lapply(COVARIATES[,ContCovariates], as.character)
COVARIATES[,ContCovariates] = lapply(COVARIATES[,ContCovariates], as.numeric)
```
Correlation/association between covariates at an FDR <= 0.1
```{r covariates.correlation, cache=FALSE, fig.width=10, fig.height=6}
COVARIATES.CORRELATION = getAssociationStatistics(COVARIATES, PVAL = 0.05)
draw(COVARIATES.CORRELATION$plot, heatmap_legend_side = 'left', padding  = unit(c(18,2,2,18), 'mm'))
```
### Explore metadata
```{r data.explore, cache=FALSE, fig.width = 12, fig.height = 8}

##--Combo--##METADATA <- METADATA[ METADATA$Tissue == 'ACC', ]
counts <- counts[ , METADATA$SampleID]
##--Combo--##COVARIATES=COVARIATES[ COVARIATES$Tissue == 'ACC' ,]
my.theme = theme(legend.position = 'top', axis.text.x = element_text(angle = 90, hjust = 1))
# RIN
p = list()
p[[1]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = RIN)) + geom_boxplot()
p[[1]] = p[[1]] + ggtitle('RIN') + my.theme
# AgeAtDeath
p[[2]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = as.numeric(Age_of_Death))) + geom_boxplot()
p[[2]] = p[[2]] + ggtitle('Age_of_Death') + my.theme
# PMI
p[[3]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = as.numeric(PMI))) + geom_boxplot()
p[[3]] = p[[3]] + ggtitle('PMI') + my.theme
# Ribosomal bases
p[[4]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = as.numeric(rRNARate))) + geom_boxplot()
p[[4]] = p[[4]] + ggtitle('Fraction of Ribosomal Bases') + my.theme
# Intronic bases
p[[5]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = as.numeric(IntronicRate))) + geom_boxplot()
p[[5]] = p[[5]] + ggtitle('Fraction Intronic Bases') + my.theme
# Intergenic bases
p[[6]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = as.numeric(IntergenicRate))) + geom_boxplot()
p[[6]] = p[[6]] + ggtitle('Fraction Intergenic Bases') + my.theme
multiplot(plotlist = p, cols = 3)
```

### Filter genes
* Remove genes that have less than 1 cpm counts in at least 50% of samples per Tissue x Diagnosis
* Remove genes with missing gene length and percentage GC content
```{r filter.genes}

COUNT<-counts[,METADATA$SampleID]
row.names(COVARIATES) <- METADATA$SampleID

Unis <- do.call(rbind, strsplit(as.character(row.names(COUNT)), '\\.'))[,1]
dups <- Unis[ duplicated(Unis) ]
Prosps <- do.call(rbind, strsplit(as.character(row.names(COUNT)), '\\.'))
Prosps <- Prosps[ (Prosps[,1] %in% dups) == F,]
keeps <- paste0( Prosps[,1], '.', Prosps[,2] )

COUNT <- COUNT[ keeps, ]

row.names(COUNT) <- do.call(rbind, strsplit(as.character(row.names(COUNT)), '\\.'))[,1]

#colnames(COVARIATES)[1] <- 'SampleID'
#colnames(COUNT) <- paste0( "CMC_", gsub("RNA_BP_PFC_","",colnames(COUNT)) )
#colnames(COUNT) <- gsub("RNA_PFC_","",colnames(COUNT)) 
#colnames(COUNT) <- gsub("RNA_ACC_","",colnames(COUNT)) 
#colnames(COUNT) <- gsub("BP_","",colnames(COUNT)) 
#tmp <- do.call(rbind, strsplit(colnames(COUNT), '_'))
#tmp[,3] <- str_pad(tmp[,3], 3, pad = "0")
#colnames(COUNT) <- paste0(tmp[,1], '_', tmp[,2], '_',tmp[,3])
#COVARIATES$SampleID <- as.character(COVARIATES$SampleID)
#row.names(COVARIATES) <- COVARIATES$SampleID
#table(METADATA$SampleID %in% colnames(COUNT))
#table(colnames(COUNT) %in% METADATA$SampleID )

genesToAnalyze = COVARIATES %>%
  rownameToFirstColumn('SampleID') %>%
  dlply(.(Dx.Tissue), .fun = function(mtd, count){
    processed.counts = getGeneFilteredGeneExprMatrix(count[,mtd$SampleID],
                                                     MIN_GENE_CPM=1, 
                                                     MIN_SAMPLE_PERCENT_WITH_MIN_GENE_CPM=0.5)
    
    #processed.counts = getGeneFilteredGeneExprMatrix(COUNT[,METADATA$SampleID],
                                                     #MIN_GENE_CPM=1, 
                                                     #MIN_SAMPLE_PERCENT_WITH_MIN_GENE_CPM=0.5)
    processed.counts$filteredExprMatrix$genes
  }, COUNT)


GENE.PARAM = syn_temp$get('syn21156161', version = 3)$path %>% 
  read.table(sep = '\t', header = T, stringsAsFactors = F)
#row.names(GENE.PARAM) <- GENE.PARAM$ensembl_gene_id
GENE.LEN = dplyr::select(GENE.PARAM, ensembl_gene_id, gene.length) %>% unique()
rownames(GENE.LEN) = GENE.LEN$ensembl_gene_id
GENE.GC = dplyr::select(GENE.PARAM, ensembl_gene_id, percentage_gc_content) %>% unique()
rownames(GENE.GC) = GENE.GC$ensembl_gene_id

genesToAnalyze = unlist(genesToAnalyze) %>% 
  unique() %>%
  intersect(GENE.GC$ensembl_gene_id[!is.na(GENE.GC$percentage_gc_content)]) %>%
  intersect(GENE.LEN$ensembl_gene_id[!is.na(GENE.LEN$gene.length)]) %>%
  setdiff(c("N_unmapped", "N_multimapping", "N_noFeature", "N_ambiguous"))

PROCESSED_COUNTS = getGeneFilteredGeneExprMatrix(COUNT[genesToAnalyze, ], 
                                                 MIN_GENE_CPM=0, 
                                                 MIN_SAMPLE_PERCENT_WITH_MIN_GENE_CPM=0)
# Check gene biotype
## Define biomart object
mart <- useMart(biomart = "ENSEMBL_MART_ENSEMBL", host = "jul2019.archive.ensembl.org", dataset = "hsapiens_gene_ensembl")
## Query biomart
Ensemble2HGNC <- getBM(attributes = c("ensembl_gene_id", "hgnc_symbol", "gene_biotype"),
                       filters = "ensembl_gene_id", 
                       values = PROCESSED_COUNTS$filteredExprMatrix$genes,
                       mart = mart)
summary(factor(Ensemble2HGNC$gene_biotype)) %>%
  rownameToFirstColumn('Biotype') %>%
  dplyr::rename(fraction = DF) %>%
  dplyr::mutate(fraction = fraction/dim(PROCESSED_COUNTS$filteredExprMatrix$genes)[1]) %>%
  dplyr::filter(fraction >= 0.01) %>%
  kable
```
Processing `r dim(PROCESSED_COUNTS$filteredExprMatrix)[1]` genes in `r dim(PROCESSED_COUNTS$filteredExprMatrix)[2]` samples


### Library Normalisation
Library normalisation is performed using cqn (conditional quantile normalisation)
```{r cqn}
row.names(GENE.GC) <- GENE.GC$ensembl_gene_id
row.names(GENE.LEN) <- GENE.LEN$ensembl_gene_id
# Compute offset for gene length and gc content
CQN.GENE_EXPRESSION = cqn(PROCESSED_COUNTS$filteredExprMatrix$counts, 
                          x = GENE.GC[PROCESSED_COUNTS$filteredExprMatrix$genes$genes, 'percentage_gc_content'],
                          lengths = GENE.LEN[PROCESSED_COUNTS$filteredExprMatrix$genes$genes, 'gene.length'],
                          lengthMethod = "smooth", 
                          verbose = FALSE)
CQN.GENE_EXPRESSION$E = CQN.GENE_EXPRESSION$y + CQN.GENE_EXPRESSION$offset
```

### Outlier Analysis
#### Sample outliers
Outlier analysis is performed before library normalisation with raw cpm counts
```{r outlier.analysis, cache = FALSE, fig.width = 10}
#indToRemove = c("11311_CER", "1923_CER", "1923_TCX", "11396_TCX", "11294_TCX", "11408_TCX",
#                '1950_TCX', '1950_CER', '1925_TCX', '1957_CER')
# Find principal components of expression to plot
PC <- prcomp(CQN.GENE_EXPRESSION$E, scale.=T, center = T)
# Plot first 2 PCs
plotdata <- data.frame(SampleID=rownames(PC$rotation), 
                       PC1=PC$rotation[,1], 
                       PC2=PC$rotation[,2])
plotdata <- left_join(plotdata, rownameToFirstColumn(COVARIATES, 'SampleID')) %>%
  dplyr::mutate(label = SampleID) %>%
  tidyr::separate(Dx.Tissue, c('Diagnosis', 'Tissue'), sep = '\\.')
#plotdata$label[!(plotdata$SampleID %in% indToRemove)] = ''
p <- ggplot(plotdata, aes(x=PC1, y=PC2))
p <- p + geom_point(aes(shape=Institution, color=Diagnosis, size=RIN))
p <- p + theme_bw() + theme(legend.position="top") 
p <- p + facet_grid(Tissue~.+Diagnosis, scales = 'free')
p <- p + geom_text(aes(label= label), size=4, hjust=0)
p
# Plot abberent distribution of logcpm counts
tmp1 = CQN.GENE_EXPRESSION$E %>%
  rownameToFirstColumn('Gene.ID') %>%
  tidyr::gather(SampleID, logCPM, -Gene.ID) %>%
  left_join(COVARIATES %>%
              rownameToFirstColumn('SampleID')) %>%
  tidyr::separate(Dx.Tissue, c('Tissue', 'Diagnosis'), sep = '\\.')
indToRemove <- ''
p = ggplot(tmp1 %>%
             #dplyr::filter(SampleID %in% indToRemove) %>%
             droplevels(),
           aes(x = logCPM)) + geom_density() 
p = p + theme(legend.position = 'top') + facet_grid(Tissue~.+Diagnosis)
p
indToRetain = setdiff(colnames(PROCESSED_COUNTS$filteredExprMatrix$counts), indToRemove)
PROCESSED_COUNTS$filteredExprMatrix$counts = PROCESSED_COUNTS$filteredExprMatrix$counts[,indToRetain]
CQN.GENE_EXPRESSION$E = CQN.GENE_EXPRESSION$E[,indToRetain]
COVARIATES = COVARIATES[indToRetain,]
tmp = COVARIATES %>%
  dplyr::group_by(Dx.Tissue) %>%
  dplyr::summarise(count = n()) %>%
  tidyr::separate(Dx.Tissue, c('Diagnosis', 'Tissue'), sep = '\\.') %>%
  tidyr::spread(Diagnosis, count)
```
Processing `r dim(PROCESSED_COUNTS$filteredExprMatrix)[1]` genes in `r dim(PROCESSED_COUNTS$filteredExprMatrix)[2]` samples

Based on the expression pattern following samples were tagged as outliers: `r paste(indToRemove, collapse = ', ')`

Distribution of samples are: `r kable(tmp)`


#### Gene outliers
Assign NA values to genes that are above and below 3 std deviation of its distribution
```{r winsorise.data}
# Set gene counts in specific samples that are deviating 3 sd from other samples to 3SD limit
LOG.CPM = apply(CQN.GENE_EXPRESSION$E, 1, function(x){
  mn = mean(x, na.rm = T)
  std.dev = sd(x, na.rm = T)
  
  x[x < (mn-3*std.dev)] = NA
  x[x > (mn+3*std.dev)] = NA
  return(x)
}) %>% t
#_# CQN.GENE_EXPRESSION$E = LOG.CPM[ (row.names(LOG.CPM) %in% ProbGenes) == F, ]
CQN.GENE_EXPRESSION$E.no.na = CQN.GENE_EXPRESSION$E
CQN.GENE_EXPRESSION$E.no.na[is.na(CQN.GENE_EXPRESSION$E.no.na)] = 0
LIB.SIZE = colSums(PROCESSED_COUNTS$filteredExprMatrix$counts)
NEW.COUNTS = (2^LOG.CPM) * t(replicate(dim(LOG.CPM)[1], LIB.SIZE))/1e6

dim(NEW.COUNTS)
#_# NEW.COUNTS <- NEW.COUNTS[ (row.names(NEW.COUNTS) %in% ProbGenes) == F, ]
dim(NEW.COUNTS)
```


### Sample clustering
PCA based clustering of samples
```{r decompse.normalise.data, cache=FALSE, fig.height=8, fig.width=8, results='asis', cache=FALSE}
# Find principal components of expression to plot
PC <- prcomp(CQN.GENE_EXPRESSION$E.no.na, scale.=T, center = T)
# Plot first 2 PCs
plotdata <- data.frame(SampleID=rownames(PC$rotation), 
                       PC1=PC$rotation[,1], 
                       PC2=PC$rotation[,2])
plotdata <- left_join(plotdata, rownameToFirstColumn(COVARIATES, 'SampleID')) %>%
  tidyr::separate(Dx.Tissue, c( 'Diagnosis', 'Tissue'), sep = '\\.')
p <- ggplot(plotdata, aes(x=PC1, y=PC2))
p <- p + geom_point(aes(shape=Institution, color=Diagnosis, size=RIN))
p <- p + theme_bw() + theme(legend.position="top") + facet_grid(Tissue+.~Diagnosis, scales = 'free_y')
p
```


Tree based clustering of samples
```{r decompse.normalise.data.1, cache=FALSE, fig.height=6, fig.width=10, results='asis'}
COVARIATES.tmp = (COVARIATES[,c(FactorCovariates), drop = F])
COVARIATES.tmp[is.na(COVARIATES.tmp)] = 0
tree = hclust(as.dist(t(CQN.GENE_EXPRESSION$E.no.na)))
for( i in 1:dim(COVARIATES.tmp)[2]){
  COVARIATES.tmp[,i] <- as.numeric(COVARIATES.tmp[,i])
}
COVARIATES.tmp <- COVARIATES.tmp[,2:dim(COVARIATES.tmp)[2]]
cols = WGCNA::labels2colors(COVARIATES.tmp);
WGCNA::plotDendroAndColors(tree, 
                           colors = cols, 
                           dendroLabels = FALSE, 
                           abHeight = 0.80, 
                           main = "Sample dendrogram",
                           groupLabels = colnames(COVARIATES.tmp))
```

### Distribution of samples (log cpm)
```{r lcpm.dist, cache=FALSE, fig.height=10, fig.width=20}
# Plot abberent distribution of logcpm counts
tmp1 = CQN.GENE_EXPRESSION$E %>%
  rownameToFirstColumn('Gene.ID') %>%
  tidyr::gather(SampleID, logCPM, -Gene.ID) %>%
  left_join(COVARIATES %>%
              rownameToFirstColumn('SampleID')) %>%
  tidyr::separate(Dx.Tissue, c( 'Diagnosis', 'Tissue' ), sep = '\\.')
p = ggplot(tmp1, aes(x = logCPM)) + geom_density() 
p = p + theme(legend.position = 'NONE') + facet_grid(Tissue+.~Diagnosis, scale = 'free')
p
```

Coexpression of genes 
```{r coexp1, cache=FALSE, fig.height=5, fig.width=5}
cr = cor(t(CQN.GENE_EXPRESSION$E.no.na))
hist(cr, main = 'Distribution of correlation between genes', xlab = 'Correlation')
```

### Significant Covariates
Correlation between pca of unadjusted mRNA expression and covariates are used to find significant covariates
```{r preadj.covariates, cache=TRUE}
# Find correlation between PC's of gene expression with covariates
#CQN.GENE_EXPRESSION$E.no.na <- as.data.frame(CQN.GENE_EXPRESSION$E.no.na)

row.names(METADATA) <- METADATA$SampleID
COVARIATES1 <- COVARIATES[ , (colnames(COVARIATES) %in% 'Tissue') == F]

COVARIATES1[ ,(colnames(COVARIATES1) %in% c('IntragenicRate', 'FlowcellBatch', 'SampID', 'MappedReads', 'AlignmentRate', 'LibraryBatch' )) ==F ]

COVARIATES1$Institution <- as.factor(as.character(COVARIATES1$Institution))
COVARIATES1$Individual_ID <- as.factor(as.character(COVARIATES1$Individual_ID))
#_#COVARIATES1$FlowcellBatch <- as.factor(as.character(COVARIATES1$FlowcellBatch))
COVARIATES1$Reported_Gender <- as.factor(as.character(COVARIATES1$Reported_Gender))
COVARIATES1$Dx.Tissue <- as.factor(as.character(COVARIATES1$Dx.Tissue))
COVARIATES1$RibozeroBatch <- as.factor(as.character(COVARIATES1$RibozeroBatch))
COVARIATES1$LibraryBatch <- as.factor(as.character(COVARIATES1$LibraryBatch))
#COVARIATES1$SampID <- as.factor(as.character(row.names(COVARIATES1)))
COVARIATES1$Ancestry <- as.factor(as.character(METADATA[row.names(COVARIATES1),]$Ethnicity))


preAdjustedSigCovars = runPCAandPlotCorrelations(CQN.GENE_EXPRESSION$E.no.na, 
                                                 COVARIATES1,
                                                 'NULL design(voom-normalized)', 
                                                 isKeyPlot=TRUE, 
                                                 MIN_PVE_PCT_PC = 1)
```

Significant covariates to adjust at FDR 0.1 are `r preAdjustedSigCovars$significantCovars`
```{r preadj.covariates.plot, cache=FALSE, fig.width=12, fig.height=8}
preAdjustedSigCovars[["PC_res"]][[2]]$plotData
```

### Normalisation (iterative design)
Since many covariates are correlated, re-normalising and re-adjusting COUNTS with an iterative design matrix.

NOTE:
1. Using a mixed effect model where random effect is chosen as Individual_ID
2. Adding Source, FLOWCELL and Gender a priori to variable selection
3. Primary variable of interest Tissue.Diagnosis is excluded from the pool of available covariates for selection
```{r iterative.norm, results='asis'}

# Primary variable of interest
postAdjustCovars = c('Institution', 'Reported_Gender', 'Dx' ) #c('Institution', 'Reported_Gender'); #'FlowcellBatch'
#postAdjustCovars = c('Institution', 'Reported_Gender');
# Assign residual covariates
residualCovars = setdiff(preAdjustedSigCovars$significantCovars, c(postAdjustCovars, primaryVariable, 'Individual_ID'))
residualSigCovars = preAdjustedSigCovars
covariatesEffects = preAdjustedSigCovars$Effects.significantCovars[residualCovars]
postAdjustCovars = c(postAdjustCovars, names(which.max(covariatesEffects))) %>% unique()
notEstimable = c()


#COVARIATES1$Block <- as.factor(as.character(sample(c(1:200), 496, replace = TRUE, prob = NULL)))

loopCount = 0 
while(length(residualSigCovars$significantCovars)!=0 && loopCount <= 20){
  ##__##COVARIATES1$Block <- as.factor(as.character(sample(c(1:200), 496, replace = TRUE, prob = NULL)))
  writeLines(paste0('Working on Loop: ', loopCount))
  writeLines(paste('Using following covariates in the model:',
                   paste(postAdjustCovars, collapse=', '),
                   'as fixed effects and Individual_ID/Institution as random effect'))
  
  # Post adjusted design matrix
  DM1 = getDesignMatrix(COVARIATES1[,postAdjustCovars,drop=F],Intercept = F)
  DM1$design = DM1$design[,linColumnFinder(DM1$design)$indepCols]
  
  # Estimate voom weights for dispersion control
  cnts = NEW.COUNTS; cnts[is.na(cnts)] = 0
  VOOM.GENE_EXPRESSION = voom(cnts, design=DM1$design, 
                              plot=F, na.rm = T)
  
  # Calculate correlation values of random effects
  VOOM.GENE_EXPRESSION$E = CQN.GENE_EXPRESSION$E
  correlation = parallelDuplicateCorrelation(VOOM.GENE_EXPRESSION,
                                             block = COVARIATES1$Individual_ID,
                                             ##__##block = COVARIATES1$Individual_ID,
                                             method = 'lmer')
  # correlation = list(); correlation$cor = 0.3819258
  
  if (!is.nan(correlation$cor)){
    # Re-estimate voom weights
    VOOM.GENE_EXPRESSION = voom(cnts, 
                                design=DM1$design, plot=F, 
                                block = COVARIATES1$Individual_ID,
                                ##__##block = COVARIATES1$Individual_ID,
                                correlation = correlation$cor)
    
    # Fit linear model using new weights and new design
    VOOM.ADJUSTED.FIT = lmFit(CQN.GENE_EXPRESSION$E,
                              design = DM1$design,
                              weights = VOOM.GENE_EXPRESSION$weights,
                              block = COVARIATES1$Individual_ID, 
                              ##__##block = COVARIATES1$Individual_ID,
                              correlation = correlation$cor)
    
    # Residuals after normalisation
    RESIDUAL.GENE_EXPRESSION = residuals.MArrayLM(VOOM.ADJUSTED.FIT,
                                                  CQN.GENE_EXPRESSION$E)
  } else {
    notEstimable = c(notEstimable, postAdjustCovars[length(postAdjustCovars)])
    postAdjustCovars = postAdjustCovars[1:(length(postAdjustCovars)-1)]
  }
  
  # Residual covariates to choose from
  residCovars <- setdiff(c(FactorCovariates,ContCovariates),
                         c(postAdjustCovars, primaryVariable, 'Individual_ID', notEstimable))

  residCovars <- residCovars[ (residCovars == 'Tissue') == F ]
  
  # Find PC of residual gene expression and significant covariates that are highly correlated with PCs
  expr = RESIDUAL.GENE_EXPRESSION; expr[is.na(expr)] = 0
  #_# no issue with prob genes now
  #residualSigCovars = runPCAandPlotCorrelations(expr[ (row.names(expr) %in% ProbGenes) == F, ], 
                                        #        COVARIATES1[, residCovars, drop=F], 
                                        #        'adjusted design(voom-normalized)',
                                        #        isKeyPlot=TRUE)
  writeLines(paste0('Residule Calc for Loop: ', loopCount))
  residualSigCovars = runPCAandPlotCorrelations(expr, 

                                                COVARIATES[, residCovars, drop=F], 
                                                'adjusted design(voom-normalized)',
                                                isKeyPlot=TRUE)
  
  # Add postadjusted covariates (if any)
  residCovars = setdiff(residualSigCovars$significantCovars, c(postAdjustCovars, primaryVariable, notEstimable))
  covariatesEffects = residualSigCovars$Effects.significantCovars[residCovars]
  
  postAdjustCovars = c(postAdjustCovars, names(which.max(covariatesEffects)))
  loopCount = loopCount + 1
}
modelStr <- paste(paste(gsub('_','\\\\_',postAdjustCovars), collapse=', '),
                  'as fixed effects')
tmp <- paste('Using following covariates in the final model:', modelStr)
```
`r tmp`

### Sanity check
```{r residual.adj, cache=FALSE, fig.width=12, fig.height=8}
# Find PC of residual gene expression and significant covariates that are highly correlated with PCs
residualSigCovars = runPCAandPlotCorrelations(expr, 
                                              COVARIATES1,
                                              'adjusted design(voom-normalized)',
                                              isKeyPlot=TRUE)
residualSigCovars[["PC_res"]][[2]]$plotData
```


Coexpression of genes 
```{r coexp2, cache=FALSE, fig.height=5, fig.width=5}
cr = cor(t(expr))
hist(cr, main = 'Distribution of correlation between genes', xlab = 'Correlation')
```
PCA of residual data
```{r decompse.normalise.data2.1, cache=FALSE, fig.height=10, fig.width=8, results='asis'}
# Find principal components of expression to plot
PC <- prcomp(expr, scale.=T, center = T)
# Plot first 4 PCs
plotdata <- data.frame(Individual_ID=rownames(PC$rotation), 
                       PC1=PC$rotation[,1], 
                       PC2=PC$rotation[,2])
#COVARIATES$SampleID <- COVARIATES$Individual_ID
plotdata <- left_join(plotdata, rownameToFirstColumn(COVARIATES, 'Individual_ID')) %>%
  tidyr::separate(Dx.Tissue, c('Diagnosis','Region'), sep = '\\.') %>% 
  dplyr::mutate(Region = factor(Region),
                Institution = factor(Institution))
p <- ggplot(plotdata, aes(x=PC1, y=PC2))
p <- p + geom_point(aes(shape=Institution, color=Diagnosis, size=RIN))
p <- p + theme_bw() + theme(legend.position="right") + facet_grid(Region~., scales = 'free_y')
p
```
Tree based clustering of residual data
```{r decompse.normalise.data2.2, cache=FALSE, fig.height=8, fig.width=12, results='asis'}
# Eucledian tree based analysis
COVARIATES.tmp<-COVARIATES
COVARIATES.tmp$Tissue <- as.character( METADATA[ row.names(COVARIATES.tmp), ]$Tissue )
COVARIATES.tmp$Tissue <- as.factor(COVARIATES.tmp$Tissue)
COVARIATES.tmp = data.matrix( COVARIATES.tmp[,c(FactorCovariates,"Tissue")] )
COVARIATES.tmp[is.na(COVARIATES.tmp)] = 0
tree = hclust(as.dist(t(expr)))
COVARIATES.tmp <- COVARIATES.tmp[,2:dim(COVARIATES.tmp)[2]]
cols = WGCNA::labels2colors(COVARIATES.tmp);
WGCNA::plotDendroAndColors(tree, 
                           colors = cols, 
                           dendroLabels = FALSE, 
                           abHeight = 0.80, 
                           main = "Sample dendrogram",
                           groupLabels = colnames(COVARIATES.tmp))
```

### Adjust data with covariates for Network Analysis
Identified covariates are regressed out from the expression matrix for network analysis
```{r network.adjust}
# Get design matrix
DESIGN.NET = getDesignMatrix(COVARIATES[, postAdjustCovars, drop = F], Intercept = F)
DESIGN.NET = DESIGN.NET$design[,linColumnFinder(DESIGN.NET$design)$indepCols]
# Estimate voom weights for dispersion control
VOOM.NET.WEIGHTS = voom(cnts, design=DESIGN.NET, plot=F)
# Re-estimate voom weights
VOOM.NET.WEIGHTS = voom(cnts, 
                        design = DESIGN.NET, plot=F,
                        block = COVARIATES$Donor_ID, 
                        correlation = correlation$cor)
# Fit linear model using new weights and new design
VOOM.NET.WEIGHTS$E = CQN.GENE_EXPRESSION$E
VOOM.NET.FIT = lmFit(VOOM.NET.WEIGHTS$E,
                     weights = VOOM.NET.WEIGHTS$weights,
                     design = VOOM.NET.WEIGHTS$design,
                     block = COVARIATES$Donor_ID, 
                     correlation = correlation$cor)
# Residuals after normalisation
RESIDUAL.NET.GENE_EXPRESSION = residuals.MArrayLM(VOOM.NET.FIT,
                                                  CQN.GENE_EXPRESSION$E)
```

### SVA Adjustments for eQTL analysis
Conditioned on primary variable (Tissue.Diagnosis) and identified covariates estimate surrogate variables using SVA package
```{r sva.adjust, cache=FALSE, fig.height=10, fig.width=8, results='asis'}
# remove  "FlowcellBatch",
FactorCovariates <- c("Individual_ID", "Institution", "Reported_Gender", "LibraryBatch", "Dx.Tissue", "Dx", "RibozeroBatch")
ContCovariates <- c("Age_of_Death", "PMI", "RIN", "MappedReads", "IntragenicRate", "IntronicRate", "IntergenicRate", "GenesDetected", "ExpProfEfficiency", "rRNARate", "TotalReads","AlignmentRate", "EV.1", "EV.2", "EV.3", "EV.4", "EV.5")
COVARIATES1[,FactorCovariates] = lapply(COVARIATES1[,FactorCovariates], factor)
COVARIATES1[,ContCovariates] = lapply(COVARIATES1[,ContCovariates], as.character)
COVARIATES1[,ContCovariates] = lapply(COVARIATES1[,ContCovariates], as.numeric)

# Get design matrix
DESIGN = getDesignMatrix(COVARIATES1[, c(primaryVariable[2], postAdjustCovars), drop = F], Intercept = F)

#_#DESIGN$design = DESIGN$design[,linColumnFinder(DESIGN$design)$indepCols]
# Estimate voom weights for dispersion control
VOOM.WEIGHTS = voom(cnts, design=DESIGN$design, plot=F)
# Re-estimate voom weights
VOOM.WEIGHTS = voom(cnts,
                    design=DESIGN$design, plot=F,

                    block = COVARIATES1$Individual_ID, 
                    correlation = correlation$cor)
# Fit linear model using new weights and new design
VOOM.WEIGHTS$E = CQN.GENE_EXPRESSION$E
FIT = lmFit(VOOM.WEIGHTS$E,
            weights = VOOM.WEIGHTS$weights,
            design = VOOM.WEIGHTS$design[,colnames(VOOM.NET.FIT)],
            block = COVARIATES1$Individual_ID, 
            correlation = correlation$cor)

# Get (null) design matrix
MODEL0 = DESIGN$design[,-grep(primaryVariable[2],colnames(DESIGN$design))] # Get null model by removing variable of interest
MODEL0 = MODEL0[,linColumnFinder(MODEL0)$indepCols]
MODEL1 = DESIGN$design
MODEL1 = MODEL1[,linColumnFinder(MODEL1)$indepCols]
# Get residuals from differential expression model
RESIDUAL.SVA.GENE_EXPRESSION = residuals.MArrayLM(FIT, CQN.GENE_EXPRESSION$E)
# Compute actual variance of all principal components
expr = RESIDUAL.SVA.GENE_EXPRESSION
expr[is.na(expr)] = 0
tmp = svd(expr)
actual.var = tmp$d^2/sum(tmp$d^2)
# Compute permuted variance of all principal components
permuted.var = foreach(i = 1:20, .combine = rbind) %dopar% {
  tmp.residual = t(apply(expr, 1, sample, replace = FALSE))
  tmp = svd(tmp.residual)
  permuted.var = tmp$d^2/sum(tmp$d^2)
}
permuted.var = apply(permuted.var, 2, mean)
NUM.SV = sum(actual.var >= permuted.var[1])
# Plot variance components
var.comp = data.frame(component = 1:length(actual.var), 
                      residual = actual.var, 
                      permuted.residual = permuted.var) %>%
  tidyr::gather(data, value, -component)
p = ggplot(var.comp %>% filter(component <= round(NUM.SV*1.2)), aes(x = component, y = value, color = data)) + geom_point()
p = p + geom_hline(yintercept=permuted.var[1], linetype = 'dashed') + xlab('Singular Dimension Index')
p = p + geom_vline(xintercept=NUM.SV, linetype = 'dashed') + ylab('Fraction of Variance Explained')
p = p + theme(legend.position = c(0.8, 0.8), legend.title = element_blank())
p
# Estimate surrogate variables
SURR.VAR = irwsva.build(CQN.GENE_EXPRESSION$E.no.na,
                        MODEL1, MODEL0, n.sv = NUM.SV, 
                        B = 30, tol = 1e-20)$sv
colnames(SURR.VAR) = paste0('SV',1:dim(SURR.VAR)[2])
rownames(SURR.VAR) = rownames(MODEL1)
# Estimate voom weights for dispersion control
VOOM.SVA.WEIGHTS = voom(cnts, design=cbind(MODEL1, SURR.VAR), plot=F)
# Re-estimate voom weights
VOOM.SVA.WEIGHTS = voom(cnts, 
                        design = cbind(MODEL1, SURR.VAR), plot=F,
                        block = COVARIATES1$Individual_ID, 
                        correlation = correlation$cor)
# Fit linear model using new weights and new design
VOOM.SVA.WEIGHTS$E = CQN.GENE_EXPRESSION$E
VOOM.SVA.FIT = lmFit(VOOM.SVA.WEIGHTS$E,
                     weights = VOOM.SVA.WEIGHTS$weights,
                     design = VOOM.SVA.WEIGHTS$design,
                     block = COVARIATES1$Individual_ID, 
                     correlation = correlation$cor)
# Residuals after normalisation
RESIDUAL.SVA.GENE_EXPRESSION = residuals.MArrayLM(VOOM.SVA.FIT,
                                                  CQN.GENE_EXPRESSION$E)
# Add variable of interest back to the residuals
varsToAddIn = grep("Tissue.Diagnosis", colnames(MODEL1), value = T)
RESIDUAL.SVA.GENE_EXPRESSION = RESIDUAL.SVA.GENE_EXPRESSION + 
  VOOM.SVA.FIT$coefficients[,varsToAddIn] %*% t(VOOM.SVA.FIT$design[,varsToAddIn])
```


```{r EXP_Val, include=FALSE, eval=TRUE, cache=FALSE}
################################################################################

#CMC ACC DATA
library(stringr)

Associated <- function( Tissue ){
  #'@Tissue either "ACC", or "PFC"
  
  Impute <-  as.data.frame( read.table(syn_temp$get('syn21442621')$path, header = T, sep = '\t', row.names = 1 ))
  row.names(Impute)  <- Impute$IID
  Impute <- Impute[ , colnames(Impute)[ (grepl("ENSG", colnames(Impute))) == T ] ]
  Impute <- as.data.frame(t(Impute))
  colnames(Impute) <- gsub( "BP_", "", gsub("0_", "CMC_", colnames(Impute) ))
  
  #Exp--
  Exp <- RESIDUAL.SVA.GENE_EXPRESSION #as.data.frame( read.table( syn_temp$get('syn21483472')$path, header = T, sep = '\t', row.names = 1 ))
  rownames(Exp) <- do.call( rbind, strsplit(row.names(Exp),'\\.'))[,1]
  Exp_temp <- Exp[ ,(grepl(paste0("_", Tissue, "_"), colnames(Exp)))==T ]
  #ID--
  ID <- read.csv( syn_temp$get('syn21444814')$path, header = T )
  table(colnames(Exp) %in% ID$RNAseq.Sample_RNA_ID )
  
  if( Tissue == 'PFC' ){
    colnames(Exp_temp) <- paste0( "CMC_", gsub( "RNA_", "", gsub("_RNA_PFC_", "_", gsub( "PFC_BP_", "", colnames(Exp_temp) ))))
  }else{
    if( Tissue == 'ACC' ){
      colnames(Exp_temp) <- paste0( "CMC_", gsub( "RNA_", "", gsub("_RNA_ACC_", "_", gsub( "ACC_BP_", "", colnames(Exp_temp) ))))
    }else{
      warning('Inproper Tissue Specified')
    }
  }
  Exp <- Exp_temp
  #Sync Names
  Padder <- function( names ){
    #'@names format of 'CMC_PITT_XXXX' ie colnames(Exp)
    foo <- do.call( rbind, strsplit(names, '_'))
    foo[,3] <- str_pad(foo[,3], 5, pad = "0")
    return( paste0(foo[,1], "_", foo[,2], "_", foo[,3] ) )
  }
  colnames(Exp) <- Padder( colnames(Exp) )
  colnames(Impute) <- Padder( colnames(Impute) )
  
  #Align Matices
  Impute <- Impute[ ,colnames(Impute)[ colnames(Impute) %in% colnames(Exp) ] ]
  Exp <- Exp[ ,colnames(Impute)[ colnames(Impute) %in% colnames(Exp) ] ]
  Impute <- Impute[ row.names(Impute)[ row.names(Impute) %in% row.names(Exp) ] ,]
  Exp <- Exp[ row.names(Impute)[ row.names(Impute) %in% row.names(Exp) ] ,]
  
  Correlation <- matrix(0, dim(Exp)[1], 3)
  row.names(Correlation) <- row.names(Impute)
  colnames(Correlation) <- c( "Z", "Correlation", "P-Val")
  
  Exp <- Exp[ , colnames(Impute)[colnames(Impute) %in% colnames(Exp)] ]
  Impute <- Impute[ , colnames(Impute)[colnames(Impute) %in% colnames(Exp)] ]
  
  for( Gene in row.names(Impute) ){
    temp <- na.omit(cbind( as.numeric(Impute[Gene,]), as.numeric(Exp[Gene,]) ))
    foo <- cor.test( temp[,1], temp[,2] , method = "kendall")
    Correlation[ Gene, ] <- c( as.numeric(foo$statistic), as.numeric(foo$estimate), as.numeric(foo$p.value) )
  }
  
  Correlation <- cbind( Correlation, "Log10_Pval"= -log10(Correlation[,3]))
  Correlation <- cbind( Correlation, "FDR"= p.adjust( Correlation[,3], method = "fdr", n = 13650) )
  Correlation <- cbind( Correlation, "BH"= p.adjust( Correlation[,3], method = "BH", n = 13650) )
  Correlation <- cbind( Correlation, "BF"= p.adjust( Correlation[,3], method = "bonferroni", n = 13650) )
  
  Correlation <- cbind( Correlation, "FDR_W_Only"= p.adjust( Correlation[,3], method = "fdr", n = dim(Correlation)[1]) )
  Correlation <- cbind( Correlation, "BH_W_Only"= p.adjust( Correlation[,3], method = "BH", n = dim(Correlation)[1]) )
  Correlation <- cbind( Correlation, "BF_W_Only"= p.adjust( Correlation[,3], method = "bonferroni", n = dim(Correlation)[1]) )
  
  Correlation <- as.data.frame(Correlation)
  Correlation$Sig <- 'NO'
  Correlation[ Correlation$FDR_W_Only < 0.05 & Correlation$Correlation > 0 , ]$Sig <- 'YES'
  Tab <- table(Correlation$Sig)
  
  message( paste0(Tissue, ' Mean Correlatioon: ', mean(Correlation$Correlation)) )
  message( paste0(Tissue, ' Mean Std. Dev: ', sd(Correlation$Correlation)) )
  
  ggsave( filename=paste0( Tissue, "_Val.pdf" ),
    plot = ggplot( data = Correlation, aes( x = Correlation, y = Log10_Pval, col = Sig ) ) + 
      geom_point() + ggtitle("Log10( PVal) vs. Correlation" ) + 
      theme(plot.title = element_text(hjust = 0.5)) + ylab("-Log( PValue)") ,
    device = "pdf",
    path = NULL,
    scale = 1,
    width = 25,
    height = 8.75,
    units = "in",
    dpi = 300,
    limitsize = TRUE
  )
 
  Sig <- ggplot( data = Correlation, aes( x = Correlation, y = Log10_Pval, col = Sig ) ) + 
      geom_point() + ggtitle("Log10( PVal) vs. Correlation" ) + 
      theme(plot.title = element_text(hjust = 0.5)) + ylab("-Log( PValue)") 

  setEPS()
  postscript(paste0( Tissue, "_Cor_All.eps"), onefile = TRUE)
    hist( Correlation$Correlation, breaks = 100, xlab = 'Correlation', las = 1, col = 'grey45',
        main="Correlation of All 6643 Matched Genes in CMC ACC")
  dev.off()
  Total_Hist <- hist( Correlation$Correlation, breaks = 100, xlab = 'Correlation', las = 1, col = 'grey45',
        main="Correlation of All 6643 Matched Genes in CMC ACC")
  
  setEPS()
  postscript(paste0( Tissue, "_Cor_gt5Perc.eps"), onefile = TRUE)
    hist( Correlation[Correlation$FDR_W_Only < 0.05, ]$Correlation, 
        breaks = 100, 
        xlab = 'Correlation',
        col = 'grey45',
        las = 1,
        main="Correlation of Genes with FDR Corrected P-Value < 0.05")
  dev.off()
  Filt_Hist <- hist( Correlation[Correlation$FDR_W_Only < 0.05, ]$Correlation, 
        breaks = 100, 
        xlab = 'Correlation',
        col = 'grey45',
        las = 1,
        main="Correlation of Genes with FDR Corrected P-Value < 0.05")
  return(list( TAB=Tab, Correlation=Correlation, Sig = Sig, Tot=Total_Hist, Filt=Filt_Hist ))
}


ACC_Plots <- Associated( 'ACC' )
PFC_Plots <- Associated( 'PFC' )
#save.image('Completed_Validation_Analysis.RData')
```


#### Imputed Expression Component Validation in DLPFC
```{r PlotDLPFC, cache=FALSE, fig.height=10, fig.width=8, results='asis'}
# Significant after correction for multiple comparisons:
print(PFC_Plots$TAB)

print("Log PValue versus Correlation:")
PFC_Plots$Sig

print("All Correlations:")
plot(PFC_Plots$Tot)

print("Significant Correlations:")
plot(PFC_Plots$Filt)
```


#### Imputed Expression Component Validation in ACC
```{r PlotACC, cache=FALSE, fig.height=10, fig.width=8, results='asis'}
# Significant after correction for multiple comparisons:
print(ACC_Plots$TAB)

print("Log PValue versus Correlation:")
ACC_Plots$Sig

print("All Correlations:")
plot(ACC_Plots$Tot)

print("Significant Correlations:")
plot(ACC_Plots$Filt)
```

#### Down Sample the DLPFC to look like ACC
```{r DownSample, cache=FALSE, fig.height=10, fig.width=8, results='asis'}
Tissue <- 'PFC'
  
Impute <-  as.data.frame( read.table(syn_temp$get('syn21442621')$path, header = T, sep = '\t', row.names = 1 ))
row.names(Impute)  <- Impute$IID
Impute <- Impute[ , colnames(Impute)[ (grepl("ENSG", colnames(Impute))) == T ] ]
Impute <- as.data.frame(t(Impute))
colnames(Impute) <- gsub( "BP_", "", gsub("0_", "CMC_", colnames(Impute) ))
  
#Exp--
Exp <- RESIDUAL.SVA.GENE_EXPRESSION #as.data.frame( read.table( syn_temp$get('syn21483472')$path, header = T, sep = '\t', row.names = 1 ))
rownames(Exp) <- do.call( rbind, strsplit(row.names(Exp),'\\.'))[,1]
Exp_temp <- Exp[ ,(grepl(paste0("_", Tissue, "_"), colnames(Exp)))==T ]
#ID--
ID <- read.csv( syn_temp$get('syn21444814')$path, header = T )
table(colnames(Exp) %in% ID$RNAseq.Sample_RNA_ID )
  
if( Tissue == 'PFC' ){
  colnames(Exp_temp) <- paste0( "CMC_", gsub( "RNA_", "", gsub("_RNA_PFC_", "_", gsub( "PFC_BP_", "", colnames(Exp_temp) ))))
}else{
  if( Tissue == 'ACC' ){
    colnames(Exp_temp) <- paste0( "CMC_", gsub( "RNA_", "", gsub("_RNA_ACC_", "_", gsub( "ACC_BP_", "", colnames(Exp_temp) ))))
  }else{
    warning('Inproper Tissue Specified')
  }
}
Exp <- Exp_temp
#Sync Names
Padder <- function( names ){
  #'@names format of 'CMC_PITT_XXXX' ie colnames(Exp)
  foo <- do.call( rbind, strsplit(names, '_'))
  foo[,3] <- str_pad(foo[,3], 5, pad = "0")
  return( paste0(foo[,1], "_", foo[,2], "_", foo[,3] ) )
}
colnames(Exp) <- Padder( colnames(Exp) )
colnames(Impute) <- Padder( colnames(Impute) )
  
#Align Matices
Impute <- Impute[ ,colnames(Impute)[ colnames(Impute) %in% colnames(Exp) ] ]
Exp <- Exp[ ,colnames(Impute)[ colnames(Impute) %in% colnames(Exp) ] ]
Impute <- Impute[ row.names(Impute)[ row.names(Impute) %in% row.names(Exp) ] ,]
Exp <- Exp[ row.names(Impute)[ row.names(Impute) %in% row.names(Exp) ] ,]
  
Perm <- function( Exp, Impute ){  
  Template <- colnames(Exp)[ colnames(Exp) %in% colnames(Impute) ]
  SAMP <- sample(Template, 381, replace = FALSE, prob = NULL)
  Impute <- Impute[ , SAMP ]
  Exp <- Exp[ , SAMP ]
  
  Correlation <- matrix(0, dim(Exp)[1], 3)
  row.names(Correlation) <- row.names(Impute)
  colnames(Correlation) <- c( "Z", "Correlation", "P-Val")
  
  Exp <- Exp[ , colnames(Impute)[colnames(Impute) %in% colnames(Exp)] ]
  Impute <- Impute[ , colnames(Impute)[colnames(Impute) %in% colnames(Exp)] ]
  
  for( Gene in row.names(Impute) ){
    temp <- na.omit(cbind( as.numeric(Impute[Gene,]), as.numeric(Exp[Gene,]) ))
    foo <- cor.test( temp[,1], temp[,2] , method = "kendall")
    Correlation[ Gene, ] <- c( as.numeric(foo$statistic), as.numeric(foo$estimate), as.numeric(foo$p.value) )
  }
  
  Correlation <- cbind( Correlation, "Log10_Pval"= -log10(Correlation[,3]))
  Correlation <- cbind( Correlation, "FDR"= p.adjust( Correlation[,3], method = "fdr", n = 13650) )
  Correlation <- cbind( Correlation, "BH"= p.adjust( Correlation[,3], method = "BH", n = 13650) )
  Correlation <- cbind( Correlation, "BF"= p.adjust( Correlation[,3], method = "bonferroni", n = 13650) )
  
  Correlation <- cbind( Correlation, "FDR_W_Only"= p.adjust( Correlation[,3], method = "fdr", n = dim(Correlation)[1]) )
  Correlation <- cbind( Correlation, "BH_W_Only"= p.adjust( Correlation[,3], method = "BH", n = dim(Correlation)[1]) )
  Correlation <- cbind( Correlation, "BF_W_Only"= p.adjust( Correlation[,3], method = "bonferroni", n = dim(Correlation)[1]) )
  
  Correlation <- as.data.frame(Correlation)
  Correlation$Sig <- 'NO'
  Correlation[ Correlation$FDR_W_Only < 0.05 & Correlation$Correlation > 0 , ]$Sig <- 'YES'
  Tab <- table(Correlation$Sig)
  return( t(as.data.frame(Tab))['Freq',] )
}  

set.seed(42)
P <- 100
temp <- foreach( i=1:P ) %dopar% Perm( Exp, Impute )
Ps <- do.call( rbind, temp )
Ps <- as.data.frame( Ps )
Ps$V1 <- as.numeric(as.character(Ps$V1))
Ps$V2 <- as.numeric(as.character(Ps$V2))

MEAN <- mean( Ps[ , 2 ]/(  Ps[ , 2 ] +  Ps[ , 1 ]) )
print( paste0('Mean Downsampled Validation: ', MEAN ))
SD <- sd( Ps[ , 2 ]/(  Ps[ , 2 ] +  Ps[ , 1 ]))
error <- qt(0.975, df=dim(Ps)[1]-1)*sd( Ps[ , 2 ]/(  Ps[ , 2 ] +  Ps[ , 1 ]) )/sqrt( dim(Ps)[1] )

```

```{r synapse.parameters, include=FALSE, cache=TRUE}
parentId = 'syn18936948';
activityName = 'Covariate and Diagnosis Regression';
activityDescription = 'CMC Covariate analysis and Regresison of AD Diagnosis of aligned effective counts with GRCh38 with CQN normalisation';
thisFileName <- 'CMC_ExpVal_DataProcessing.Rmd'
# Github link
thisRepo <- githubr::getRepo(repository = "jgockley62/TWAS", ref="branch", refName='master')
thisFile <- githubr::getPermlink(repository = thisRepo, repositoryPath=paste0('code/',thisFileName))
```

### Store files in synapse
```{r synapse.store, include=FALSE, eval=TRUE, cache=FALSE}
activityName = 'CMC Covariate and Diagnosis Regression';
activityDescription = 'CMC Covariate analysis and Regrssion of Diagnosis of aligned effective counts with GRCh38 with CQN normalisation CMC';
CODE <- syn_temp$store(synapseclient$Folder(name = "CMC_Analysis", parentId = parentId))

#Set Used SynIDs For Provenance
Syns_Used <- c('syn21444814', 'syn21442621', 'syn16816490', 'syn16816488', 'syn21156161', 'syn16783596', 'syn16783867', 'syn2511399', 'syn16783557','syn16783508', 'syn16783557' )

# Set annotations
all.annotations = list(
  dataType = 'mRNA',
  dataSubType = 'geneExp',
  summaryLevel = 'gene',
  assay	 = 'RNAseq',
  tissueTypeAbrv	= NULL, 
  study = 'CMC', 
  organism = 'HomoSapiens',
  consortium	= 'CMC',
  normalizationStatus	= TRUE,
  normalizationType	= 'CQN',
  rnaquantification = 'RSEM',
  genomeAssemblyID = 'GRCh38'
)

# Store SVA results
write.table(RESIDUAL.SVA.GENE_EXPRESSION, file = 'CMC_SVA_Diagnosis_Corrected.tsv', sep = '\t', quote=F)
ENRICH_OBJ <-  syn_temp$store( synapseclient$File( path='CMC_SVA_Diagnosis_Corrected.tsv', name = 'Normalised, covariates, surrogate and Diagnosis variable adjusted residual expression (for eQTL)', parentId=CODE$properties$id ), activityName = activityName, executed = c( Syns_Used, thisFile) , activityDescription = activityDescription)
  all.annotations$dataSubType = 'residualGeneExpForeQTL'
  syn_temp$setAnnotations(ENRICH_OBJ, annotations = all.annotations)
  
# Store residual gene expression for network analysis
RESIDUAL.NET.GENE_EXPRESSION %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  write.table(file = 'CMC_Diagnosis_Regressed_netResidualExpression.tsv', sep = '\t', row.names=F, quote=F)
ENRICH_OBJ <-  syn_temp$store( synapseclient$File( path='CMC_Diagnosis_Regressed_netResidualExpression.tsv', name = 'Normalised, covariates and Diagnosis removed residual expression (for network analysis)', parentId=CODE$properties$id ), activityName = activityName, executed = c( Syns_Used, thisFile) , activityDescription = activityDescription)
  all.annotations$dataSubType = 'residualGeneExpForNetAnlz'
  syn_temp$setAnnotations(ENRICH_OBJ, annotations = all.annotations)
  
#Upload Plots:
ENRICH_OBJ <-  syn_temp$store( synapseclient$File( path='ACC_Val.pdf', name = 'LogP value as a function of correlation for ACC', parentId=CODE$properties$id ), activityName = activityName, executed = c( Syns_Used, thisFile) , activityDescription = activityDescription)
  all.annotations$tissueTypeAbrv = 'ACC'
  syn_temp$setAnnotations(ENRICH_OBJ, annotations = all.annotations)

ENRICH_OBJ <-  syn_temp$store( synapseclient$File( path='ACC_Cor_All.eps', name = 'Histogram of all correlation values for ACC', parentId=CODE$properties$id ), activityName = activityName, executed = c( Syns_Used, thisFile) , activityDescription = activityDescription)
  all.annotations$tissueTypeAbrv = 'ACC'
  syn_temp$setAnnotations(ENRICH_OBJ, annotations = all.annotations)

ENRICH_OBJ <-  syn_temp$store( synapseclient$File( path='ACC_Cor_gt5Perc.eps', name = 'Histogram of Significant correlation values for ACC', parentId=CODE$properties$id ), activityName = activityName, executed = c( Syns_Used, thisFile) , activityDescription = activityDescription)
  all.annotations$tissueTypeAbrv = 'ACC'
  syn_temp$setAnnotations(ENRICH_OBJ, annotations = all.annotations)
    
ENRICH_OBJ <-  syn_temp$store( synapseclient$File( path='PFC_Val.pdf', name = 'LogP value as a function of correlation for DLPFC', parentId=CODE$properties$id ), activityName = activityName, executed = c( Syns_Used, thisFile) , activityDescription = activityDescription)
  all.annotations$tissueTypeAbrv = 'DLPFC'
  syn_temp$setAnnotations(ENRICH_OBJ, annotations = all.annotations)

ENRICH_OBJ <-  syn_temp$store( synapseclient$File( path='PFC_Cor_All.eps', name = 'Histogram of all correlation values for DLPFC', parentId=CODE$properties$id ), activityName = activityName, executed = c( Syns_Used, thisFile) , activityDescription = activityDescription)
  all.annotations$tissueTypeAbrv = 'DLPFC'
  syn_temp$setAnnotations(ENRICH_OBJ, annotations = all.annotations)

ENRICH_OBJ <-  syn_temp$store( synapseclient$File( path='PFC_Cor_gt5Perc.eps', name = 'Histogram of Significant correlation values for DLPFC', parentId=CODE$properties$id ), activityName = activityName, executed = c( Syns_Used, thisFile) , activityDescription = activityDescription)
  all.annotations$tissueTypeAbrv = 'DLPFC'
  syn_temp$setAnnotations(ENRICH_OBJ, annotations = all.annotations)
  
#ENRICH_OBJ <-  syn_temp$store( synapseclient$File( path='Completed_Validation_Analysis.RData', name = 'RData object of analysis for ACC Validation', parentId=CODE$properties$id ), activityName = activityName, executed = c( Syns_Used, thisFile) , activityDescription = activityDescription)
#  all.annotations$tissueTypeAbrv = 'Analysis'
#  syn_temp$setAnnotations(ENRICH_OBJ, annotations = all.annotations)

```

### R Source Code
[Github](`r thisFile`)

```{r knitmd, eval=FALSE, cache=FALSE, include=FALSE}
reticulate::use_python("/usr/bin/python", required = TRUE)
synapseclient <- reticulate::import("synapseclient")
syn_temp <- synapseclient$Synapse()
syn_temp$login()

setwd("~/TWAS/code/")
source("~/TWAS/utilityFunctions/knitfile2synapseClient.R")
source("~/TWAS/utilityFunctions/hook_synapseMdSyntax_plot.R")
createAndKnitToFolderEntityClient(file = "CMC_ExpVal_DataProcessing.Rmd",
                                          parentId ="syn18936948",
                                          #parentId ="syn21478397",
                                          folderName = 'CMC_Analysis')
```
